#!/usr/bin/env perl

# --------------------------------------------------------------------
# モジュールロード
# --------------------------------------------------------------------

use strict;
use utf8;
use Encode qw/encode decode/;
use Data::Dumper;
use Getopt::Long qw/GetOptions/;
use Cwd;
$| = 1;

# --------------------------------------------------------------------
# 下準備：変数用意、マクロ用意
# --------------------------------------------------------------------

# -- 環境判別
my $is_win = $^O =~ /MSWin/; # Windows
my $is_mac = $^O =~ /darwin/; # Mac OSX
my $is_linux = !($is_win || $is_mac); # Mac Linux

# -- コマンド出力の制御
my $hide_err = $is_win ? '2>NUL'     : '2>/dev/null';     # エラーのみ非表示
my $hide_all = $is_win ? '>NUL 2>&1' : '>/dev/null 2>&1'; # エラーと標準出力両方とも非表示

# -- 設定格納ディレクトリ
my $genie_dir = $ENV{GENIE_DIR} || '.genie';

# -- sayコマンドが使えるか否か
my $can_say;
if($is_win) {
	`where wscript $hide_all`;
	$can_say = !$?;
} elsif ($is_mac) {
	`which say $hide_all`;
	$can_say = !$?;
}

# -- ブラウザ起動コマンド
my $open_cmd;
   if($is_win  ) { $open_cmd = 'start'; }
elsif($is_mac  ) { $open_cmd = 'open'; }
elsif($is_linux) {
	`xdpyinfo >/dev/null 2>&1`;
	$open_cmd = 'xdg-open' if(!$?);
}

# -- Windows向けにShift-JIS出力関数を通す関数を先に用意
sub echo { print encode($is_win ? 'Shift_JIS' : 'UTF-8', shift) }

# -- 設定値変数
my %config;

print "\n";

# --------------------------------------------------------------------
# 起動オプション、設定ファイル読み込み
# --------------------------------------------------------------------

# -- コマンドオプション設定
GetOptions(
	'm=s' => \$config{GENERAL}->{runmode},
	'c=s' => \$config{GENERAL}->{config_name},
);
$config{GENERAL}->{runmode} ||= 'develop';    # 未指定の場合 `develop` として動作します。
$config{GENERAL}->{config_name} ||= 'config'; # 未指定の場合 `.genie/config.pl` を読み込みます。

# -- .genieディレクトリがあるパスを探して移動する
my $genie_path = "./$genie_dir";
my $now_path = Cwd::getcwd();
$now_path =~ s/^([A-Za-z])\:\//\//; # ドライブレター削除（for Windows）
$config{GENERAL}->{drive_letter} = lc $1;
my @dirs = split('/', $now_path);
while(@dirs){
	my $genie_path = join('/', @dirs);
	if(-d "$genie_path/$genie_dir") {
		$config{GENERAL}->{home_path} = $genie_path;
		chdir $genie_path;
		last;
	}
	pop @dirs;
}

# -- 設定ファイルをロード
$config{GENERAL}->{config_path} = "$config{GENERAL}->{home_path}/$genie_dir/$config{GENERAL}->{config_name}.pl";
if(-f $config{GENERAL}->{config_path}){
	# -- 設定を読み込み
	my $r = require $config{GENERAL}->{config_path};
	%config = (%config, %$r);
} else {
	unless($ARGV[0] eq '' || grep{$ARGV[0] eq $_} qw/eject clean init ls httpd demo/){ # ←設定ファイルが無くても実行可能なものを列挙
		throw("設定ファイル（$config{GENERAL}->{config_path}）が先祖パスに見つかりません。\n`genie init`をお忘れではないですか？");
	}
}

# -- データベース設定でLABELが重複していないか確認
foreach my $db_type (qw|MYSQL POSTGRESQL|) {
	my @err;
	my %book;
	map { if($book{$_->{LABEL}}++){push @err, $_->{LABEL};} } @{$config{$db_type}->{DATABASES}};
	throw("${db_type}の設定で、重複するラベルがあります。", join("\n", @err)) if @err;
}


# --------------------------------------------------------------------
# Dockerマシーン環境用意
# ※設定がされていたら。
# --------------------------------------------------------------------

# -- docker-machineコマンドが存在してるかどうか
`docker-machine`;
my $is_docker_machine = !$?;

# -- ホストIPを設定
if($config{DOCKER}->{HOST_IP_FORCE}){
	$config{GENERAL}->{host_ip} = $config{DOCKER}->{HOST_IP_FORCE};
} else {
	if($is_docker_machine) {
		my $ip = `docker-machine ip $config{DOCKER}->{MACHINE}`;
		chomp $ip;
		$config{GENERAL}->{host_ip} = $ip;
	} else {
		$config{GENERAL}->{host_ip} = '127.0.0.1';
	}
}

# -- Dockerマシーンが指定されていれば切り替える
if($is_docker_machine && $config{DOCKER}->{MACHINE} ne '') {
	# -- docker-machine起動
	my $cmd = 'docker-machine start ' . $config{DOCKER}->{MACHINE}. ' ' . $hide_err;
	my $result = `$cmd`;
	if(!$?) {
	 	if($result !~ /^Starting/) {
			throw('Dockerマシンの起動に失敗しました。', $cmd);
	 	}
	} else {
		# -- docker-machineの環境切り替え
		$cmd = 'docker-machine env ' . $config{DOCKER}->{MACHINE} . ' ' . $hide_err;
		foreach my $line (split(/[\r\n]+/, `$cmd`)) {
			if($line =~ /(DOCKER_\w+)\s*\=\s*\"?([^\"]+)\"?/) {
				$ENV{$1} = $2;
			}
		}
	}
}

# --------------------------------------------------------------------
# 処理分け
# --------------------------------------------------------------------

# -- 第一引数により関数にジャンプ
if( grep{ $ARGV[0] eq $_ } qw /
	demo
	init
	up
	down
	cmd
	cli
	config
	ls
	eject
	clean
	httpd
	build
	php
	perl
	ruby
	store
	restore
	ngrok
	mysql
	psql
	open
/ ){
	no strict;
	$ARGV[0]->();

	# -- 終了処理
	style(color=>'black', bgcolor=>'dark_black');
	echo "  EOL\n\n";
	style(color=>'clear', bgcolor=>'clear');

	# -- genie正常完了
	exit 0;
}

# --------------------------------------------------------------------
# コマンド引数ヘルプ表示
# --------------------------------------------------------------------

echo "\n";
echo "Usage: genie COMMAND [arg...] [OPTIONS]\n";
echo "\n";
echo <<HELP;
\x1b[36mGENERAL\x1b[0m  | up                    起動（コンテナ作成）＆再起動
\x1b[36mCOMMANDS\x1b[0m | down                  終了（コンテナ削除）
         | version               kazaoki/genieのバージョンを表示
         | info                  詳細を表示
         | upgrade               kazaoki/genieのアップグレード
         | config                設定値を表示する
         | ip                    ホストIPを表示する
         | cli                   コマンドラインに入る
         | logs                  主要ログを表示する
         | htop                  htop実行
         | ngrok                 ngrokを使って外部に公開
         | cmd                   コンテナ内でコマンドを実行
         | build                 独自Dockerfileをビルドする
         | eject                 '$config{DOCKER}->{NAME}'コンテナ強制rm、all→全dockerコンテナ強制rm
         | clean                 不要なコンテナ、<none>イメージ、未参照のデータボリュームを削除
         | -m [RUNMODE]          実行モード：product|develop
         | -c [CONFIG TYPE]      設定タイプ：標準は general

\x1b[36mDATABASE\x1b[0m | mysql                 mysql実行
\x1b[36mCOMMANDS\x1b[0m | psql                  psql実行
         | dump                  ダンプ
         | restore               リストア
         | -d [DB CONNECT ID]    DB接続ID
         | -f [DB DUMP FILE]     対象のDBダンプファイル

\x1b[36mBROWSER\x1b[0m  | open                  ブラウザ起動
\x1b[36mCOMMANDS\x1b[0m | -s [URI SCHEMA]       httpかhttpsかを指定（未指定ならhttp）
         | -p [WEB PORT]         ポートを指定
         | -u [URL PATH]         パスを指定

\x1b[36mTEST\x1b[0m     | test [FEATURES]       テストを実行
\x1b[36mCOMMANDS\x1b[0m | -r [REPORT MAIL TO]   実行後のレポートHTMLの送り先

\x1b[36mOTHER\x1b[0m    | ftpsync               指定のFTPからDL同期
\x1b[36mCOMMANDS\x1b[0m | deploy                指定のGitリポジトリからpull同期
         | rmi-none              <none>状態のdockerイメージを全て削除

HELP

exit 0;

# --------------------------------------------------------------------
# ヘルパー関数
# --------------------------------------------------------------------

# メッセージ表示ヘルパー
# ----------------------
sub message {
	my ($type, $message, $line) = @_;
	my @messages = split(/[\r\n]+/, $message);
	my %style;
	my %clear = (color=>'clear', bgcolor=>'clear', weight=>'clear', decoratiinfo=>'clear');
	
	   if($type eq 'default' ) { %style = (color=>'dark_white'); }
	elsif($type eq 'primary' ) { %style = (color=>'blue'); }
	elsif($type eq 'success' ) { %style = (color=>'green'); }
	elsif($type eq 'info'    ) { %style = (color=>'cyan'); }
	elsif($type eq 'warning' ) { %style = (color=>'yellow'); }
	elsif($type eq 'danger'  ) { %style = (color=>'red'); }
	elsif($type eq 'disabled') { %style = (color=>'black'); }

	my $width;
	foreach(@messages) {
		my $len = length Encode::encode('cp932', $_);
		if($width<$len) { $width = $len; }
	}
	style(%style);

	echo '  +' . ('-' x ($width+2)) . "+\n";
	my $count;
	foreach(@messages) {
		my $len = length Encode::encode('cp932', $_);
		echo '  | ';
		echo $_;
		echo ' ' x ($width==$len ? 0 : $width-$len);
		echo " |\n";
		if(++$count==$line) {
			echo '  +' . ('-' x ($width+2)) . "+\n";
		}
	}
	echo '  +' . ('-' x ($width+2)) . "+\n";
	style(%clear);
	print "\n";
}

# カラーセットヘルパー
# --------------------
# style(
# 	color      => 'red',
# 	bgcolor    => 'blue',
# 	weight     => 'bold',
# 	decoration => 'undeline',
# );
sub style {
	my %style = @_;
	my($color, $bgcolor) = @_;
	my %colors = (
		black        => "\x1b[90m", dark_black   => "\x1b[30m",
		red          => "\x1b[91m", dark_red     => "\x1b[31m",
		green        => "\x1b[92m", dark_green   => "\x1b[32m",
		yellow       => "\x1b[93m", dark_yellow  => "\x1b[33m",
		blue         => "\x1b[94m", dark_blue    => "\x1b[34m",
		magenta      => "\x1b[95m", dark_magenta => "\x1b[35m",
		cyan         => "\x1b[96m", dark_cyan    => "\x1b[36m",
		white        => "\x1b[97m", dark_white   => "\x1b[37m",
		clear        => "\x1b[39m",
	);
	my %bgcolors = (
		black        => "\x1b[100m", dark_black   => "\x1b[40m",
		red          => "\x1b[101m", dark_red     => "\x1b[41m",
		green        => "\x1b[102m", dark_green   => "\x1b[42m",
		yellow       => "\x1b[103m", dark_yellow  => "\x1b[43m",
		blue         => "\x1b[104m", dark_blue    => "\x1b[44m",
		magenta      => "\x1b[105m", dark_magenta => "\x1b[45m",
		cyan         => "\x1b[106m", dark_cyan    => "\x1b[46m",
		white        => "\x1b[107m", dark_white   => "\x1b[47m",
		clear        => "\x1b[49m",
	);
	my %weight = (
		bold    => "\x1b[1m",
		clear   => "\x1b[0m",
	);
	my %decoration = (
		underline => "\x1b[4m",
		clear     => "\x1b[0m",
	);
	my $set = '';
	$set .= $colors{$style{color}} ? $colors{$style{color}} : '';
	$set .= $bgcolors{$style{bgcolor}} ? $bgcolors{$style{bgcolor}} : '';
	$set .= $weight{$style{weight}} ? $weight{$style{weight}} : '';
	$set .= $decoration{$style{decoration}} ? $decoration{$style{decoration}} : '';
	print $set if $set;
}

# コンテナが起動しているか確認するヘルパー
# ----------------------------------------
# 引数未指定の場合はkazaoki/genieのコンテナ名
sub is_up {
	my $container_name = shift;
	my $cmd = 'docker top ' . ($container_name || $config{DOCKER}->{NAME});
	`$cmd $hide_all`;
	return !$?;
}

# コンテナが存在しているか確認するヘルパー
# ----------------------------------------
# 起動してなくても存在さえしていれば１を返す
sub is_exist {
	my $container_name = shift;
	my $cmd = 'docker inspect ' . ($container_name || $config{DOCKER}->{NAME});
	`$cmd $hide_all`;
	return !$?;
}

# 起動してない場合はエラーを表示するヘルパー
# ------------------------------------------
sub require_up {
	if(!is_up()) {
		message(warning=>'起動してません：' . $config{DOCKER}->{NAME});
		return;
	}
	return 1;
}

# データ入力ヘルパー
# ------------------
sub input {
	my $string = shift;
	my $tail_space = shift || 20;
	my $len = (length Encode::encode('cp932', $string)) + 2 + $tail_space;
	style(color=>'white', bgcolor=>'blue');
	echo ' ' x $len . "\n";
	echo "  $string".(' 'x$tail_space)."\n";
	echo ' ' x $len . "\n";
	style(color=>'white', bgcolor=>'dark_blue');
	echo ' ' x $len . "\n";
	style(color=>'white', bgcolor=>'blue');
	echo "\e[3A\e[".($len-$tail_space)."C";
	my $input = <STDIN>;
	echo "\e[2B";
	style(color=>'clear', bgcolor=>'clear');
	return decode('sjis', $input);
}

# エラー終了ヘルパー
# ------------------
sub throw {
	my($message, $detail) = @_;
	if($detail) {
		message(danger=>"$message\n$detail", scalar(split(/\n/, $message)));
	} else {
		message(danger=>$message);
	}
	exit 1;
}

# スピーチヘルパー
# ----------------
sub say {
	return if(!$can_say);
	my $message = encode($is_win ? 'Shift_JIS' : 'UTF-8', shift);
	if($is_mac) {
	    `say -r 300 "$message"`;
	} elsif ($is_win) {
		`wscript $config{GENERAL}->{drive_letter}\:$config{GENERAL}->{home_path}/$genie_dir/say.js "$message"`;
	}
}

# 使用中のデータボリューム名を返す
# --------------------------------
sub get_data_volume_name {
	my $container_name = shift;
	my @volumes;
	my @lines = `docker inspect --format='{{.Mounts}}' $container_name $hide_err` =~ /\{\s*([^\{\}]+)\s*\}/g;
	foreach(@lines){
		if( $_=~/^(.+?) / && $1!~/\// ) {
			push @volumes, $1;
		}
	}
	return @volumes;
}

# 指定コンテナの内部IPを返す
# --------------------------
sub get_container_ip {
	my $container_name = shift;
	my $ip = `docker inspect --format='{{.NetworkSettings.IPAddress}}' $container_name $hide_err`;
	chomp $ip;
	return $ip;
}

# コンテナ側処理をプログレスを表示しながら待つ
# --------------------------------------------
# [例]
# &wait_container(
#     container_name => 'genie-test',
#     log_file       => '/var/log/apache.log',
#     stop_word      => 'done',
#     label          => 'Start',
#     label_head     => ' ',   # default '  | '
#     progress_char  => '+',   # default '.'
#     result_ok      => ' ok', # default ' OK'
#     result_ng      => ' ng', # default ' NG'
#     sleep_sec      => 5,     # default 1
# );
# `container_name`コンテナ内の`log_file`に`stop_word`が見つかるまでループします。
# ※log_file未指定の場合は、標準出力(docker logs)の値から探します。
sub wait_container {
	my $param = shift;
	# -- コンテナ名チェック
	if(!$param->{container_name}){
		throw('コンテナ名が指定されていません。');
	}
	if(!is_up($param->{container_name})){
		throw("指定のコンテナ `$param->{container_name}` に接続出来ませんでした。")
	}
	# -- 停止ワードチェック
	if(!$param->{stop_word}){
		throw('停止ワードが指定されていません。');
	}
	# -- デフォルト値セット
	$param->{label}          ||= '';
	$param->{label_head}     ||= '  | - ';
	$param->{progress_char}  ||= '.';
	$param->{result_ok}      ||= 'OK';
	$param->{result_ng}      ||= 'NG';
	$param->{sleep_sec}      ||= 1;

	# -- ラベル表示
	echo "$param->{label_head}$param->{label} ";

	my $error;
	my $loop = 1;
	my $progress_count = 0;
	my $cmd =
		$param->{log_file}
			? qq|docker exec $param->{container_name} sh -c "cat $param->{log_file} 2>/dev/null \| grep '$param->{stop_word}' \| wc -l"|
			: qq|docker logs $param->{container_name} 2>&1|
	;
	do {
		# -- 生存確認
		if(is_up($param->{container_name})){
			# -- ログファイルをチェック
			if($param->{log_file}) {
				my $hit_count = `$cmd`;
				chomp $hit_count;
				if($hit_count) {
					undef $loop;
				} else {
					echo $param->{progress_char};
					$progress_count ++;
					sleep $param->{sleep_sec};
				}
			}
			# -- 標準出力をチェック
			else {
				my $log = `$cmd`;
				$log = decode('UTF-8', $log);
				if(grep { index($_, $param->{stop_word})!=-1 } split(/[\r\n]+/, $log)) {
					undef $loop;
				} else {
					echo $param->{progress_char};
					$progress_count ++;
					sleep $param->{sleep_sec};
				}
			}
		} else {
			# -- コンテナが死んでる場合
			$error = `docker logs $param->{container_name} 2>&1`;
			$error ||= 'コンテナが削除された可能性があります。';
			undef $loop;
		}
	} while($loop);

	# -- 完了表示
	if(!$error){
		# -- 成功
		style(color=>'green');
		if($progress_count) { print ' '; }
		echo "$param->{result_ok}";
		style(color=>'clear');
	} else {
		# -- エラー
		style(color=>'red');
		echo " $param->{result_ng}";
		style(color=>'clear');
		my @lines = split(/[\r\n]+/, $error);
		if(scalar(@lines) > 10 ) {
			@lines = splice(@lines, -10, 10); # エラーメッセージが110行以上なら最後から10行のみ表示
		}
		print "\n";
		message(danger=>join("\n", @lines));
	}

	print "\n";

	return;
}

# --------------------------------------------------------------------
# genie init                                                    初期化
# --------------------------------------------------------------------
sub init {

	# -- カレントに設定ディレクトリ作成
	if( -d $genie_dir) {
		throw("$genie_dir ディレクトリが既にあるので処理を中止します。");
	} else {
		mkdir $genie_dir;
	}
	if( -d $genie_dir) {
		message(success=>"$genie_dir ディレクトリを作成しました。");
	} else {
		throw("$genie_dir ディレクトリが作成できませんでした。");
	}

	# -- config.plの作成
	{
		my $result = open my $fh, '>:raw', "$genie_dir/config.pl"
			or throw("設定ファイル `$genie_dir/config.pl` が作成できませんでした。")
		;
		print $fh encode('UTF-8', <<'EOL');
return {

	# Docker設定
	# ----------
	DOCKER => {
		IMAGE   => 'kazaoki/genie',
		MACHINE => '',
		NAME    => 'genie-test',
	},

	# ネットワーク設定
	# ----------------
	NETWORK => {
		HOSTS_ME => [
			'site.com',
			'www.site.com',
			'smtp.gmail.com',
		],
		HOSTS_ETC => [
			# {''=>'site.com'},
		],
	},

	# Apache設定
	# ----------
	APACHE => {
		PUBLIC_PATH => '../www',
		BANDWIDTH => '',
	},

	# Postfix設定
	# -----------
	POSTFIX => {
		FORCE_ENVELOPE => 'xxx@xxx.xxx',
	},

};
EOL
		close $fh;
	}

	# -- entry.shの作成
	{
		my $result = open my $fh, '>:raw', "$genie_dir/entry.sh"
			or throw("設定ファイル `$genie_dir/entry.sh` が作成できませんでした。")
		;
		print $fh encode('UTF-8', <<'EOL');
#!/bin/sh

# -- daemon loop start
while true
do
    sleep 60
done
EOL
		close $fh;
	}

	# -- say.jsの作成（Windowsの場合のみ）
	if($is_win) {
		my $result = open my $fh, '>:raw', "$genie_dir/say.js"
			or throw("`$genie_dir/say.js` が作成できませんでした。")
		;
		print $fh encode('UTF-8', <<'EOL');
var args = [];
for(var i = 0; i < WScript.Arguments.length; i++) args.push(WScript.Arguments.Item(i));
WScript.CreateObject('SAPI.SpVoice').Speak('<volume level="100">'+'<rate speed="2">'+'<pitch middle="0">'+args.join(' ')+'</pitch>'+'</rate>'+'</volume>', 8);
EOL
		close $fh;
	}

}

# --------------------------------------------------------------------
# genie demo                                                      デモ
# --------------------------------------------------------------------
sub demo {

	# -- カラーメッセージBOX
	foreach(qw/default primary success info warning danger disabled/) {
		message($_=>$_);
	}
	message(warning=>"複数行も\n可能です!!");
	message(default=>"1箇所なら\nライン入れも\n可能であります。",2);

	# -- 入力BOX
	my $input = input('入力BOX：');
	print "\n";
	message(default=>"入力された文字：$input");

	# -- sayテスト
	say($input);

	# -- エラー終了
	throw('エラーテスト', '終了ステータス1で終わります');
}

# --------------------------------------------------------------------
# genie up                                                起動・再起動
# --------------------------------------------------------------------
sub up {

	# -- 既存のシステムを終了させる
	down();

	# -- 起動
	if(!-s $config{GENERAL}->{home_path}."/$genie_dir/entry.sh"){
		throw("$config{GENERAL}->{home_path}/$genie_dir/entry.sh が見当たりませんので起動できません。");
	}
	echo "  Starting containers\n";

	# -- -v 用にホームパスをいじる（Windowsのみドライブレターが必用なので）
	my $vpath = $is_win ? '/'.$config{GENERAL}->{drive_letter}.$config{GENERAL}->{home_path} : $config{GENERAL}->{home_path};

	# -- MySQL起動
	my $mysql_option;
	my $mysql_last_label; # 最後に起動したコンテナを起動プログレス表示に使用
	if($config{MYSQL}->{ENABLED}) {
		# -- スクリプトパーミッション設定
		chmod 0755, "$config{GENERAL}->{home_path}/$genie_dir/mysql/before-entry.sh";
		# -- コンテナ起動
		foreach my $db (@{$config{MYSQL}->{DATABASES}}) {
			my $label = $config{DOCKER}->{NAME} . "-mysql-" . $db->{LABEL};
			$mysql_last_label = $label;
			my $cmd =
				"docker run --name $label".
				" -v $vpath/$genie_dir/:/genie".
				" -e MYSQL_LABEL=$db->{LABEL}".
				" -e MYSQL_ROOT_PASSWORD=$db->{PASS}".
				" -e MYSQL_DATABASE=$db->{NAME}".
				" -e MYSQL_USER=$db->{USER}".
				" -e MYSQL_PASSWORD=$db->{PASS}".
				" -e MYSQL_PORT=$db->{PORT}".
				" -e MYSQL_CHARSET=$db->{CHARSET}".
				" -e TERM=xterm".
				($db->{HOST} ? " --add-host=$db->{HOST}:127.0.0.1" : '' ).
				" -p ".($db->{HOST_PORT} ? "$db->{HOST_PORT}:$db->{PORT}" : $db->{PORT}).
				" --entrypoint=/genie/mysql/before-entry.sh".
				" -d $db->{REPOSITORY}".
				" mysqld"
			;
			`$cmd`;

			# -- 起動開始のプログレス
			wait_container ({
				container_name => $label,
				log_file       => '/var/log/init.log',
				stop_word      => 'Process start',
				label          => "MySQL container start ($label)",
			});
			
			# -- 本体からリンク
			$mysql_option .= " --link $label";

			# -- HOST情報をセット
			if($db->{HOST}) {
				$mysql_option .= ' --add-host='.$db->{HOST}.':'.get_container_ip($label);
			}

		}
	}

	# -- PostgreSQL起動
	my $postgresql_option;
	my $postgresql_last_label; # 最後に起動したコンテナを起動プログレス表示に使用
	if($config{POSTGRESQL}->{ENABLED}) {
		# -- スクリプトパーミッション設定
		chmod 0755, "$config{GENERAL}->{home_path}/$genie_dir/postgresql/before-entry.sh";
		# -- コンテナ起動
		foreach my $db (@{$config{POSTGRESQL}->{DATABASES}}) {
			my $label = $config{DOCKER}->{NAME} . "-postgresql-" . $db->{LABEL};
			$postgresql_last_label = $label;
			my $cmd =
				"docker run --name $label".
				" -v $vpath/$genie_dir/:/genie".
				" -e MYSQL_ROOT_PASSWORD=$db->{PASS}".
				" -e POSTGRES_LABEL=$db->{LABEL}".
				" -e POSTGRES_HOST=$db->{HOST}".
				" -e POSTGRES_DB=$db->{NAME}".
				" -e POSTGRES_USER=$db->{USER}".
				" -e POSTGRES_PASSWORD=$db->{PASS}".
				" -e POSTGERS_PORT=$db->{PORT}".
				" -e POSTGERS_ENCODING=$db->{ENCODING}".
				" -e POSTGERS_LOCALE=$db->{LOCALE}".
				" -e TERM=xterm".
				" -p ".($db->{HOST_PORT} ? "$db->{HOST_PORT}:$db->{PORT}" : $db->{PORT}).
				" --entrypoint=/genie/postgresql/before-entry.sh".
				" -d $db->{REPOSITORY}".
				" postgres"
			;
			`$cmd`;

			# -- 起動開始のプログレス
			wait_container ({
				container_name => $label,
				log_file       => '/var/log/init.log',
				stop_word      => 'Process start',
				label          => "PostgreSQL container start ($label)",
			});

			# -- 本体からリンク
			$postgresql_option .= " --link $label";

			# -- HOST情報をセット
			if($db->{HOST}) {
				$postgresql_option .= ' --add-host='.$db->{HOST}.':'.get_container_ip($label);
			}

		}
	}

	# -- 本体の起動（Apache）
	{
		# -- 設定値を環境変数として渡す形(-e)に変換
		my %envs;
		my $make_envs;
		$make_envs = sub {
			my($var, $label) = @_;
			$label = uc $label;
			if(!ref $var) {
				$var =~ s/\"//g;
				if($envs{$label} ne '') {
					$envs{$label} .= ",$var";
				} else {
					$envs{$label} = $var;
				}
			}
			elsif(ref $var eq 'ARRAY') {
				my $count = 1;
				foreach(@{$var}){
					if(ref $_ eq 'HASH') {
						&$make_envs($_, "${label}_${count}");
					} else {
						&$make_envs($_, $label);
					}
					$count ++; # ハッシュアレイの場合、1から番号を振る
				}
			}
			elsif(ref $var eq 'HASH') {
				foreach(keys %{$var}){
					&$make_envs($var->{$_}, ($label ne '' ? "${label}_" : '').$_);
				}
			}
		};
		&$make_envs(\%config, 'GENIE');
		my $envs = join(' ', map { sprintf('-e %s="%s"', $_, $envs{$_}) } sort(keys %envs));

		# -- add hosts
		my $add_host;
		if(ref $config{DOCKER}->{HOSTS}) {
			foreach(@{$config{DOCKER}->{HOSTS}}){
				$add_host .= qq| --add-host="$_"|;
			}
		}

		# -- runコマンドの作成
		my $cmd =
			'docker run -d'.
			' -e TERM=xterm'.
			" -v $vpath/$genie_dir:/genie".
			" -v $vpath/$config{APACHE}->{PUBLIC_PATH}:/var/www/html".
			$mysql_option.
			$postgresql_option.
			$add_host.
			" -p ".($config{APACHE}->{HOST_PORT_HTTP} ? "$config{APACHE}->{HOST_PORT_HTTP}:80" : 80).
			" -p ".($config{APACHE}->{HOST_PORT_HTTPS} ? "$config{APACHE}->{HOST_PORT_HTTPS}:443" : 443).
			" --name=$config{DOCKER}->{NAME}".
			# " --privileged".
			" $envs".
			($config{DOCKER}->{OPTIONS} ? " $config{DOCKER}->{OPTIONS}" : '').
			" $config{DOCKER}->{IMAGE}"
		;

		# -- runコマンドの実行
		my $cid = `$cmd`;
		if($?){
			throw('genie本体の起動に失敗しました。');
		}
		$cid =~ /^(.{12})/;
		my $short_cid = $1;

		# -- 起動プログレスまとめ（各コンテナは並行処理なのでウェイト処理はここでまとめる）
		{

			# -- kazaoki/genie本体
			wait_container ({
				container_name => $config{DOCKER}->{NAME},
				log_file       => '/var/log/entry.log',
				stop_word      => 'entry.sh setup start.',
				label          => "Genie container start ($config{DOCKER}->{NAME})",
			});

			# -- entry.sh：ストレージ復元
			if(glob("$config{GENERAL}->{home_path}/$genie_dir/storages/*.tar")) {
				wait_container ({
					container_name => $config{DOCKER}->{NAME},
					log_file       => '/var/log/entry.log',
					stop_word      => 'Storages restore done.',
					label          => 'Storages restore',
				});
			}

			# -- entry.sh：Perl
			if($config{PERL}->{VERSION}){
				wait_container ({
					container_name => $config{DOCKER}->{NAME},
					log_file       => '/var/log/entry.log',
					stop_word      => 'Perl setup done.',
					label          => "Perl setup (version $config{PERL}->{VERSION})",
				});
			}

			# -- entry.sh：cpanfile
			if($config{PERL}->{CPANFILE_ENABLED}){
				wait_container ({
					container_name => $config{DOCKER}->{NAME},
					log_file       => '/var/log/entry.log',
					stop_word      => 'cpanfile setup done.',
					label          => "cpanfile setup",
				});
			}

			# -- entry.sh：PHP
			if($config{PHP}->{VERSION}){
				wait_container ({
					container_name => $config{DOCKER}->{NAME},
					log_file       => '/var/log/entry.log',
					stop_word      => 'PHP setup done.',
					label          => "PHP setup (version $config{PHP}->{VERSION})",
				});
			}

			# -- entry.sh：Ruby
			if($config{RUBY}->{VERSION}){
				wait_container ({
					container_name => $config{DOCKER}->{NAME},
					log_file       => '/var/log/entry.log',
					stop_word      => 'Ruby setup done.',
					label          => "Ruby setup (version $config{RUBY}->{VERSION})",
				});
			}

			# -- entry.sh：Apache
			wait_container ({
				container_name => $config{DOCKER}->{NAME},
				log_file       => '/var/log/entry.log',
				stop_word      => 'Apache setup done.',
				label          => "Apache setup",
			});

			# -- entry.sh：Postfix
			if($config{POSTFIX}->{ENABLED}){
				wait_container ({
					container_name => $config{DOCKER}->{NAME},
					log_file       => '/var/log/entry.log',
					stop_word      => 'Postfix setup done.',
					label          => "Postfix setup",
				});
			}

			# -- after.sh
			wait_container ({
				container_name => $config{DOCKER}->{NAME},
				log_file       => '/var/log/entry.log',
				stop_word      => 'after.sh setup done.',
				label          => "after.sh setup",
			});

			# -- MySQL
			if($config{MYSQL}->{ENABLED}) {
				wait_container ({
					container_name => $mysql_last_label,
					stop_word      => 'MySQL init process done. Ready for start up.',
					label          => 'MySQL ready',
				});
			}

			# -- PostgreSQL
			if($config{POSTGRESQL}->{ENABLED}) {
				wait_container ({
					container_name => $postgresql_last_label,
					stop_word      => 'データベースシステムの接続受付準備が整いました。',
					label          => 'PostgreSQL ready',
				});
			}

			print "\n";
		}

		# -- コンテナの情報からブラウザを起動
		if(`docker port $cid 80` =~ /(\d+)$/) {
			my $url = "http://$config{GENERAL}->{host_ip}" .($1==80 ? '' : ":$1"). "/";
			message(success=>"起動完了しました：$config{DOCKER}->{NAME}\n$url", 1);
			if($open_cmd){
				`$open_cmd $url`;
			}
		}

	}
}

# --------------------------------------------------------------------
# genie down                                                      終了
# --------------------------------------------------------------------
# ※mode='silent' でドットプログレスに。
sub down {
	my $mode = shift;

	# -- 対象コンテナピックアップ
	my @exist_containers;
	my @rm_volumes;

	# -- MySQL
	if(ref $config{MYSQL}->{DATABASES}) {
		foreach(@{$config{MYSQL}->{DATABASES}}){
			my $label = $config{DOCKER}->{NAME} . "-mysql-" . $_->{LABEL};
			if(is_exist($label)){
				push @exist_containers, $label;
				push @rm_volumes, get_data_volume_name($label);
			}
		}
	}

	# -- PostgreSQL
	if(ref $config{POSTGRESQL}->{DATABASES}) {
		foreach(@{$config{POSTGRESQL}->{DATABASES}}){
			my $label = $config{DOCKER}->{NAME} . "-postgresql-" . $_->{LABEL};
			if(is_exist($label)){
				push @exist_containers, $label;
				push @rm_volumes, get_data_volume_name($label);
			}
		}
	}

	# -- genie本体
	if(is_exist($config{DOCKER}->{NAME})){
		push @exist_containers, $config{DOCKER}->{NAME};
		push @rm_volumes, get_data_volume_name($config{DOCKER}->{NAME});
	}

	# -- 削除開始
	if(@exist_containers) {
		style(color=>'black', bgcolor=>'dark_black');
		echo "  Deleting exist container".(scalar(@exist_containers)>1 ? 's' : '') . "\n";
		foreach my $label (@exist_containers){
			echo "  | - $label ";
			`docker rm -f $label $hide_all`;
			if($?) {
				style({color=>'red'});
				echo "NG\n";
				style({color=>'clear'});
			} else {
				echo "deleted\n";
			}
		}
		style(color=>'clear', bgcolor=>'clear');
		print "\n";

		# -- ストレージボリュームを削除（未参照状態にならないと消えないので最後に実行）
		if(@rm_volumes) {
			my $cmd = 'docker volume rm ' . join(' ', @rm_volumes) . " $hide_all";
		}
	}
}

# --------------------------------------------------------------------
# genie cli                                       コマンドラインに入る
# --------------------------------------------------------------------
sub cli {
	return unless require_up(); # 起動必須

	my $cmd = 'docker exec -it ' . $config{DOCKER}->{NAME} . ' /bin/bash';
	system($cmd);
	echo "\n";
}

# --------------------------------------------------------------------
# genie cmd                                         コマンドを実行する
# --------------------------------------------------------------------
sub cmd {
	return unless require_up(); # 起動必須

	my $cmd = 'docker exec ' . $config{DOCKER}->{NAME} . ' ' . join(' ', @ARGV[1..$#ARGV]);
	`$cmd`;
}

# --------------------------------------------------------------------
# genie ls                            マシン、イメージ、コンテナの一望
# --------------------------------------------------------------------
sub ls {

	# -- Dockerマシン一覧
	if($is_docker_machine) {
		echo "  Dockerマシン一覧\n";
		my $result = `docker-machine ls`;
		message(info=>$result, 1);
		print "\n";
	}

	# -- ACTIVEマシンのイメージ一覧
	{
		echo "  イメージ一覧\n";
		my $result = `docker images`;
		message(info=>$result, 1);
	}

	# -- ACTIVEマシンのデータボリューム一覧
	{
		echo "  データボリューム一覧\n";
		my $result = `docker volume ls`;
		message(info=>$result, 1);
	}

	# -- ACTIVEマシンのコンテナ一覧
	{
		echo "  コンテナ一覧\n";
		my $result = `docker ps -a`;
		message(info=>$result, 1);
	}
	print "\n";
}

# --------------------------------------------------------------------
# genie eject                         コンテナやイメージを強制削除する
# --------------------------------------------------------------------
sub eject {

	# -- configで指定しているgenieコンテナを強制削除する
	if($ARGV[1] eq '') {
		`docker inspect -f {{.Name}} $config{DOCKER}->{NAME} $hide_all`;
		if($?) {
			message(warning=>"コンテナが見つかりません。：$config{DOCKER}->{NAME}");
		} else {
			`docker rm -f $config{DOCKER}->{NAME} $hide_all`;
			message(success=>"コンテナを強制削除しました。：$config{DOCKER}->{NAME}");
		}
		# コンテナ一覧を表示
		my $result = `docker ps -a`;
		message(info=>$result, 1);
	}

	# -- dockerコンテナを全て強制削除する
	elsif($ARGV[1] eq 'all') {
		my @list = split(/[\r\n]+/, `docker ps -qa`);
		if(@list) {
			my @err;
			foreach my $id (@list) {
				echo "  $id - ";
				`docker rm -f $id`;
				if($?) {
					style(color=>'red'); echo "Failed!\n"; style(color=>'clear');
					push @err;
				} else {
					style(color=>'green'); echo "Deleted.\n"; style(color=>'clear');
				}
			}
			if(@err) {
				message(danger=>'強制削除に失敗したコンテナがあります。\n'.join('',map{"- $_\n"}@err));
			} else {
				message(success=>'全てのコンテナを強制削除しました');
			}
		} else {
			message(warning=>'コンテナが１つも見つかりませんでした。');
		}
		# コンテナ一覧を表示
		my $result = `docker ps -a`;
		message(info=>$result, 1);
	}

}

# --------------------------------------------------------------------
# genie clean               不要なコンテナやイメージ、ボリュームを削除
# --------------------------------------------------------------------
sub clean {

	# -- 終了済みコンテナを削除
	{
		my @list = split(/[\r\n]+/, `docker ps -qa --filter status=exited`);
		if(@list) {
			my @err;
			foreach my $id (@list) {
				echo "  $id - ";
				`docker rm $id`;
				if($?) {
					style(color=>'red'); echo "Failed!\n"; style(color=>'clear');
					push @err;
				} else {
					style(color=>'green'); echo "Deleted.\n"; style(color=>'clear');
				}
			}
			if(@err) {
				message(danger=>'削除に失敗したコンテナがあります。\n'.join('',map{"- $_\n"}@err));
			} else {
				message(success=>'全ての終了済みコンテナを削除しました。');
			}
		} else {
			message(default=>'終了済みコンテナは見つかりませんでした。');
		}
	}

	# -- <none>イメージを削除する
	{
		my @list = split(/[\r\n]+/, `docker images -q --filter dangling=true`);
		if(@list) {
			my @err;
			foreach my $id (@list) {
				echo "  $id - ";
				`docker rmi $id`;
				if($?) {
					style(color=>'red'); echo "Failed!\n"; style(color=>'clear');
					push @err;
				} else {
					style(color=>'green'); echo "Deleted.\n"; style(color=>'clear');
				}
			}
			if(@err) {
				message(danger=>'削除に失敗した<none>イメージがあります。\n'.join('',map{"- $_\n"}@err));
			} else {
				message(success=>'全ての<none>イメージを削除しました。');
			}
		} else {
			message(default=>'<none>イメージは見つかりませんでした。');
		}
	}

	# -- 未参照のデータボリュームを削除する
	{
		my @list = split(/[\r\n]+/, `docker volume ls -q --filter dangling=true`);
		if(@list) {
			my @err;
			foreach my $id (@list) {
				echo "  $id - ";
				`docker volume rm $id`;
				if($?) {
					style(color=>'red'); echo "Failed!\n"; style(color=>'clear');
					push @err;
				} else {
					style(color=>'green'); echo "Deleted.\n"; style(color=>'clear');
				}
			}
			if(@err) {
				message(danger=>'削除に失敗した未参照のデータボリュームがあります。\n'.join('',map{"- $_\n"}@err));
			} else {
				message(success=>'全ての未参照のデータボリュームを削除しました。');
			}
		} else {
			message(default=>'未参照のデータボリュームは見つかりませんでした。');
		}
	}
}


# --------------------------------------------------------------------
# genie config                                    設定の内容を確認する
# --------------------------------------------------------------------
sub config {

	# -- エディタオープン
	if ($ARGV[1] eq 'open') {
		my $conf = $config{GENERAL}->{config_path};
		if($is_win) {
			$conf = "$config{GENERAL}->{drive_letter}\:$config{GENERAL}->{config_path}";
		}
		return `$open_cmd $conf`;
	}

	message(info=>Dumper(\%config));
}

# --------------------------------------------------------------------
# genie httpd             簡易ローカルWebサーバ起動（設定ファイル不必要）
# --------------------------------------------------------------------
sub httpd {

	# -- 公式httpdイメージから起動
	my $vpath = $is_win ? '/'.$config{GENERAL}->{drive_letter}.$now_path : $now_path;
	my $cmd = "docker run -d -p 80 -v $vpath:/var/www/html/ php:5.6-apache";
	my $cid = `$cmd`;
	if($?) {
		throw('Webサーバが起動しませんでした。', $cmd);
	}
	chomp $cid;

	# -- コンテナの情報からブラウザを起動
	if(`docker port $cid 80` =~ /(\d+)$/) {

		# -- ブラウザ起動
		my $url = "http://$config{GENERAL}->{host_ip}:$1/";
		message(success=>$url);
		if($open_cmd){
			`$open_cmd $url`;
		}

		# -- Ctrl+C時に自動的にコンテナ削除されるように
		if($is_win) {
			# Winの場合
			$SIG{INT} = sub {
				print "\nDeleting container $cid ...\n\n";
				`docker rm -f $cid`;
			};
			system("docker logs -f $cid");
		} else {
			# Mac/Linuxの場合
			system("docker logs -f $cid");
			print "\nDeleting container $cid ...\n\n";
			`docker rm -f $cid`;
		}

	} else {
		throw('サーバは起動しましたが、ポートが取得できませんでした。');
	}
}

# --------------------------------------------------------------------
# genie build             簡易ローカルWebサーバ起動（設定ファイル不必要）
# --------------------------------------------------------------------
sub build {

	# -- nocacheオプション
	my $nocache = '--no-cache' if ($ARGV[1] eq 'nocache');

	# -- .genie/Dockerfileをビルドする
	my $dockerfile = $config{GENERAL}->{home_path}."/$genie_dir/Dockerfile";
	if(! -s $dockerfile){
		throw('Dockerfileが見つからないか、空ファイルです。', $dockerfile);
	}

	# -- 確認
	my $input;
	if($is_docker_machine) {
		my $machine_name = $config{DOCKER}->{MACHINE} || `docker-machine active`;
		chomp $machine_name;
		$input = input(
			sprintf(
				'%s マシーンに %s イメージをビルドしてもよろしいでしょうか。[y/N]:',
				$machine_name,
				$config{DOCKER}->{IMAGE},
			)
		);
	} else {
		$input = input(
			sprintf(
				'%s イメージをビルドしてもよろしいでしょうか。[y/N]:',
				$config{DOCKER}->{IMAGE},
			)
		);
	}

	print "\n";
	if($input =~ /^y$/i ) {
		# -- ビルド実行
		my $cmd =
			"docker build".
			" -t $config{DOCKER}->{IMAGE}".
			($config{DOCKER}->{OPTIONS_BUILD} ? " $config{DOCKER}->{OPTIONS_BUILD}" : '').
			" $nocache $config{GENERAL}->{home_path}/$genie_dir/"
		;
		message(info=>"ビルドを開始します。\n$cmd");
		my $result = `$cmd`;
		if($?) {
			throw('ビルドに失敗しました。', $result);
		}
		# -- イメージ一覧表示
		message(success=>'ビルド完了しました。');
		$cmd = `docker images`;
		message(info=>$cmd, 1);
	}
}

# --------------------------------------------------------------------
# genie php                                                    PHP情報
# --------------------------------------------------------------------
sub php {
	return unless require_up(); # 起動必須
	print `docker exec -it $config{DOCKER}->{NAME} /root/.anyenv/envs/phpenv/plugins/php-build/bin/php-build --definitions`;
	print "\n---\n\n";
	print `docker exec $config{DOCKER}->{NAME} bash -c ". /root/.bashrc && phpenv versions"`;
	print "\n";
}

# --------------------------------------------------------------------
# genie perl                                                  Perl情報
# --------------------------------------------------------------------
sub perl {
	return unless require_up(); # 起動必須

	# -- cpanfileのモジュールインストールアップデート
	if($ARGV[1] eq 'cpanfile-update') {
		message(info=>'/genie/cpanfileを元にperlのモジュールをアップデートします。');
		my $cmd;
		if($config{PERL}->{VERSION}) {
			$cmd = "docker exec $config{DOCKER}->{NAME} cpanm -nq --installdeps /genie/"; # バージョン指定のplenv環境のときは自動的に/storages/perl内にインストールされる
		} else {
			$cmd = "docker exec $config{DOCKER}->{NAME} cpanm -nq --installdeps -L /storages/perl-cpanfile-modules/ /genie/"; # system perlのときは明示的にストレージの中を指定する
		}
		`$cmd`;
		if($?) {
			throw('cpanfileのモジュールインストールアップデートに失敗しました。', $cmd);
		}
		message(success=>'cpanfileのモジュールインストールアップデートに成功しました。');
		my $result = input('/genie/storages/perl-cpanfile-modules.tar に固めますか？ [y/N]:');
		if($result =~ /^y$/i ) {
			$ARGV[1] = 'perl';
			&store();
		}
		return;
	}

	print `docker exec -it $config{DOCKER}->{NAME} /root/.anyenv/envs/plenv/plugins/perl-build/perl-build  --definitions`;
	print "\n---\n\n";
	print `docker exec $config{DOCKER}->{NAME} bash -c ". /root/.bashrc && plenv versions"`;
	print "\n";
}

# --------------------------------------------------------------------
# genie ruby                                                  Ruby情報
# --------------------------------------------------------------------
sub ruby {
	return unless require_up(); # 起動必須
	print `docker exec -it $config{DOCKER}->{NAME} /root/.anyenv/envs/rbenv/plugins/ruby-build/bin/ruby-build  --definitions`;
	print "\n---\n\n";
	print `docker exec $config{DOCKER}->{NAME} bash -c ". /root/.bashrc && rbenv versions"`;
	print "\n";
}

# --------------------------------------------------------------------
# genie store (storage name)                          ストレージの保存
# --------------------------------------------------------------------
sub store {
	my $param = shift;
	return unless require_up(); # 起動必須
	if($ARGV[1] eq '') { throw('引数が足りません。ストレージ名を指定してください。（/storages/xxx/のxxxの部分）'); }

	# -- ストレージ名の整理
	my $storage_name = $ARGV[1];
	my $dir_path = "/storages/$storage_name";
	my $tar_path = "/genie/storages/${storage_name}.tar";

	# -- ストレージパスの存在確認
	`docker exec $config{DOCKER}->{NAME} ls $dir_path $hide_all`;
	if($?) {
		throw('ご指定のストレージが見つかりません。', "$storage_name ( $dir_path )");
	}

	# -- tarで固める
	my $opt;
	if(defined $param->{opt}) {
		$opt = $param->{opt};
	}
	mkdir "$genie_dir/storages";
	my $cmd = qq|docker exec $config{DOCKER}->{NAME} sh -c "cd $dir_path && tar cvf $tar_path ./ $opt"|;
	`$cmd`;
	if($?) {
		throw('tar保存に失敗しました。', "$dir_path -> $tar_path");
	} else {
		message(success=>"tar保存に成功しました。\n$dir_path -> $tar_path" );
	}

}

# --------------------------------------------------------------------
# genie restore (storage name)                        ストレージの復元
# --------------------------------------------------------------------
sub restore {
	return unless require_up(); # 起動必須

	if($ARGV[1] eq '') { throw('引数が足りません。ストレージ名を指定してください。（/genie/storages/xxx.tarのxxxの部分）'); }

	# -- ストレージ名の整理
	my $storage_name = $ARGV[1];
	my $dir_path = "/storages/$storage_name";
	my $tar_path = "/genie/storages/${storage_name}.tar";

	# -- ストレージtarの存在確認
	`docker exec $config{DOCKER}->{NAME} ls $tar_path $hide_all`;
	if($?) {
		throw('ご指定のtarファイルが見つかりません。', "$storage_name ( $tar_path )");
	}

	# -- tarを展開する
	my $cmd = "docker exec $config{DOCKER}->{NAME} tar xvf $tar_path -C $dir_path";

	`$cmd`;
	if($?) {
		throw('ストレージの復元に失敗しました。', "$tar_path -> $dir_path");
	} else {
		message(success=>"ストレージの復元に成功しました。\n$tar_path -> $dir_path" );
	}
}

# --------------------------------------------------------------------
# genie ngrok                                          ngrokを利用する
# --------------------------------------------------------------------
sub ngrok {
	system "docker exec -it $config{DOCKER}->{NAME} ngrok http 80";
}

# --------------------------------------------------------------------
# genie mysql (options)                                      MySQL操作
# --------------------------------------------------------------------
sub mysql {
	return unless require_up(); # 起動必須
	my @dbs = @{$config{MYSQL}->{DATABASES}} if ref $config{MYSQL}->{DATABASES};

	# -- 引数未指定または数字
	if($ARGV[1] eq '' || $ARGV[1] =~ /^\d+$/ ) {
		my $db_number = $ARGV[1] =~ /^\d+$/ ? $ARGV[1] : 1;
		unless($db_number>0 && $db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するMySQL設定が見つかりません。'); }
		my $db = $config{MYSQL}->{DATABASES}[$db_number-1];
		my $cmd =
			qq|docker exec -it $config{DOCKER}->{NAME}-mysql-$db->{LABEL}|.
			qq| mysql $db->{NAME}|.
			qq| -u$db->{USER}|.
			qq| -p$db->{PASS}|.
			qq| -P$db->{PORT}|
		;
		system $cmd;
	}
	# -- ls
	elsif($ARGV[1] eq 'ls' ) {
		my $count = 1;
		message(info=>join("\n", map { ($count++) . ': ' . $_->{LABEL} } @dbs));
	}
	# -- dump (db num) : 対象番号のDBをdump
	elsif($ARGV[1] eq 'dump') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : undef;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するMySQL設定が見つかりません。'); }
		`docker exec $config{DOCKER}->{NAME} mkdir -p /genie/mysql/dumps/ $hide_all`;
		my $count = 1;
		foreach my $db (@dbs){
			if($db_number && $db_number!=$count++) { next; }
			my $label = "$config{DOCKER}->{NAME}-mysql-$db->{LABEL}";

			# -- ダンプファイルの世代処理
			my $max_gen = $db->{DUMP_GENEL};
			foreach my $gen (reverse 1..$max_gen) {
				my $gen_str = $gen==1 ? '' : ".$gen";
				if($gen==$max_gen) {
					my $cmd = qq|docker exec $config{DOCKER}->{NAME} sh -c "rm /genie/mysql/dumps/$db->{LABEL}.sql$gen_str"|;
					`$cmd $hide_all`;
					next;
				}
				my $next = $gen + 1;
				my $cmd = qq|docker exec $config{DOCKER}->{NAME} sh -c "cd /genie/mysql/dumps/ && mv $db->{LABEL}.sql$gen_str $db->{LABEL}.sql.$next"|;
				`$cmd $hide_all`;
			}

			# -- ダンプ生成
			my $cmd = qq|docker exec $label sh -c "mysqldump --single-transaction -u $db->{USER} -p$db->{PASS} $db->{NAME} > /genie/mysql/dumps/$db->{LABEL}.sql"|;
			`$cmd $hide_all`;
			if(!$?) {
				message(success=>"MySQLのデータベース $db->{LABEL} をダンプしました。\n$genie_dir/mysql/dumps/$db->{LABEL}.sql",1);
			} else {
				throw('データベースのダンプに失敗しました。', $!);
			}
		}
	}
	# -- restore (db num) : 対象番号のDBダンプを復元 ※番号未指定なら全てのDBを復元
	elsif($ARGV[1] eq 'restore') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : undef;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するMySQL設定が見つかりません。'); }
		my $count = 1;
		foreach my $db (@dbs){
			if($db_number && $db_number!=$count++) { next; }
			`docker restart $config{DOCKER}->{NAME}-mysql-$db->{LABEL}`;
			if(!$?) {
				message(success=>"MySQLのデータベース $db->{LABEL} を復元しました。\n$genie_dir/mysql/dumps/$db->{LABEL}.sql",1);
			} else {
				throw('データベースの復元に失敗しました。', $!);
			}
		}
	}
	# -- cli (db num) : 対象番号のDBコンテナに入る ※番号未指定なら1
	elsif($ARGV[1] eq 'cli') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : 1;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するMySQL設定が見つかりません。'); }
		my $db = $config{MYSQL}->{DATABASES}[$db_number-1];
		my $cmd = "docker exec -it $config{DOCKER}->{NAME}-mysql-$db->{LABEL} bash";
		system $cmd;
	}
	# -- 引数ミス
	else{
		throw('引数が間違っています');
	}
}

# --------------------------------------------------------------------
# genie psql (options)                                  PostgreSQL操作
# --------------------------------------------------------------------
sub psql {
	return unless require_up(); # 起動必須
	my @dbs = @{$config{POSTGRESQL}->{DATABASES}} if ref $config{POSTGRESQL}->{DATABASES};

	# -- 引数未指定または数字
	if($ARGV[1] eq '' || $ARGV[1] =~ /^\d+$/ ) {
		my $db_number = $ARGV[1] =~ /^\d+$/ ? $ARGV[1] : 1;
		unless($db_number>0 && $db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するPostgreSQL設定が見つかりません。'); }
		my $db = $dbs[$db_number-1];
		my $cmd =
			qq|docker exec -it $config{DOCKER}->{NAME}-postgresql-$db->{LABEL}|.
			qq| psql $db->{NAME} -U $db->{USER} -p $db->{PORT}|
		;
		system $cmd;
	}
	# -- ls
	elsif($ARGV[1] eq 'ls' ) {
		my $count = 1;
		message(info=>join("\n", map { ($count++) . ': ' . $_->{LABEL} } @dbs));
	}
	# -- dump (db num) : 対象番号のDBをdump
	elsif($ARGV[1] eq 'dump') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : undef;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するPostgreSQL設定が見つかりません。'); }
		`docker exec $config{DOCKER}->{NAME} mkdir -p /genie/postgresql/dumps/ $hide_all`;
		my $count = 1;
		foreach my $db (@dbs){
			if($db_number && $db_number!=$count++) { next; }
			my $label = "$config{DOCKER}->{NAME}-postgresql-$db->{LABEL}";

			# -- ダンプファイルの世代処理
			my $max_gen = $db->{DUMP_GENEL};
			foreach my $gen (reverse 1..$max_gen) {
				my $gen_str = $gen==1 ? '' : ".$gen";
				if($gen==$max_gen) {
					my $cmd = qq|docker exec $config{DOCKER}->{NAME} sh -c "rm /genie/postgresql/dumps/$db->{LABEL}.sql$gen_str"|;
					`$cmd $hide_all`;
					next;
				}
				my $next = $gen + 1;
				my $cmd = qq|docker exec $config{DOCKER}->{NAME} sh -c "cd /genie/postgresql/dumps/ && mv $db->{LABEL}.sql$gen_str $db->{LABEL}.sql.$next"|;
				`$cmd $hide_all`;
			}

			# -- ダンプ生成
			my $cmd = qq|docker exec $label sh -c "pg_dump $db->{NAME} -U $db->{USER} -p $db->{PORT} > /genie/postgresql/dumps/$db->{LABEL}.sql"|;
			`$cmd`;
			if(!$?) {
				message(success=>"PostgreSQLのデータベース $db->{LABEL} をダンプしました。\n$genie_dir/postgresql/dumps/$db->{LABEL}.sql",1);
			} else {
				throw('データベースのダンプに失敗しました。', $!);
			}
		}
	}
	# -- restore (db num) : 対象番号のDBをtarからストレージに復元 ※番号未指定なら全てのDBを復元
	elsif($ARGV[1] eq 'restore') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : undef;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するPostgreSQL設定が見つかりません。'); }
		my $count = 1;
		foreach my $db (@dbs){
			if($db_number && $db_number!=$count++) { next; }
			`docker restart $config{DOCKER}->{NAME}-postgresql-$db->{LABEL}`;
			if(!$?) {
				message(success=>"PostgreSQLのデータベース $db->{LABEL} を復元しました。\n$genie_dir/postgresql/dbdata_$db->{LABEL}.tar.gz",1)
			} else {
				throw('データベースの復元に失敗しました。', $!);
			}
		}
	}
	# -- cli (db num) : 対象番号のDBコンテナに入る ※番号未指定なら1
	elsif($ARGV[1] eq 'cli') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : 1;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するPostgreSQL設定が見つかりません。'); }
		my $db = $config{POSTGRESQL}->{DATABASES}[$db_number-1];
		my $cmd = "docker exec -it $config{DOCKER}->{NAME}-postgresql-$db->{LABEL} bash";
		system $cmd;
	}
	# -- 引数ミス
	else{
		throw('引数が間違っています');
	}
}

# --------------------------------------------------------------------
# genie open                                            ブラウザを開く
# --------------------------------------------------------------------
sub open {
	# -- コンテナの情報からブラウザを起動
	if(`docker port $config{DOCKER}->{NAME} 80` =~ /(\d+)$/) {
		my $url = "http://$config{GENERAL}->{host_ip}" .($1==80 ? '' : ":$1"). "/";
		message(success=>$url);
		if($open_cmd){
			`$open_cmd $url`;
		}
	}
}
