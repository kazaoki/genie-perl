#!/usr/bin/env perl

# --------------------------------------------------------------------
# モジュールロード
# --------------------------------------------------------------------

use strict;
use utf8;
use Encode qw/encode decode/;
use Data::Dumper;
use Getopt::Long qw(:config no_auto_abbrev no_ignore_case gnu_compat pass_through);
use Cwd;
use HTTP::Date;
use LWP::Simple;
use XML::Simple; # cpan install XML::Simple
use Tie::IxHash; # cpan install Tie::IxHash
use YAML::Tiny; # cpan install YAML::Tiny
use Time::HiRes qw( gettimeofday );
$| = 1;

# -- 処理開始時間
my $start_time = gettimeofday;

# -- 許可する第一引数の正規表現
my $ok_args = join('|', qw/
	demo
	init
	update
	up
	down
	cli
	config
	ls
	reject
	clean
	httpd
	build
	php
	perl
	ruby
	ngrok
	mysql
	psql
	open
	logs
	dlsync
	spec
	zap
	compose
/);
# -- 設定ファイルが無くても実行可能な第一引数の正規表現
my $noconf_args = join('|', qw/
	reject
	clean
	init
	update
	ls
	httpd
	demo
	php
	perl
	ruby
/);

# --------------------------------------------------------------------
# 下準備：変数用意、マクロ用意
# --------------------------------------------------------------------

# -- 環境判別
my $is_win = $^O =~ /MSWin/; # Windows
my $is_mac = $^O =~ /darwin/; # Mac OSX
my $is_linux = !($is_win || $is_mac); # Mac Linux

# -- コマンド出力の制御
my $hide_err = $is_win ? '2>NUL'     : '2>/dev/null';     # エラーのみ非表示
my $hide_all = $is_win ? '>NUL 2>&1' : '>/dev/null 2>&1'; # エラーと標準出力両方とも非表示

# -- 設定格納ディレクトリ名
my $config_dir_name = '.genie';

# -- sayコマンドが使えるか否か
my $can_say;
if($is_win) {
	`where wscript $hide_all`;
	$can_say = !$?;
} elsif ($is_mac) {
	`which say $hide_all`;
	$can_say = !$?;
}

# -- ブラウザ起動コマンド
my $open_cmd;
my $open_cmd_after;
   if($is_win  ) { $open_cmd = 'start'; }
elsif($is_mac  ) { $open_cmd = 'open'; }
elsif($is_linux) {
	`xdpyinfo >/dev/null 2>&1`;
	$open_cmd = 'xdg-open' if(!$?);
	$open_cmd_after = '>/dev/null 2>&1';
}

# -- Windows向けにShift-JIS出力関数を通す関数を先に用意
sub echo { print encode($is_win ? 'Shift_JIS' : 'UTF-8', shift) }

# -- 生のsjis文字列をフラグ付きutf8にする
sub sjis2utf8 {
	my $str = shift;
	Encode::from_to($str, 'cp932', 'utf8');
	return Encode::decode('utf8', $str);
}

# -- 設定値変数
my %config;

# -- compose用変数
my $comp;

# --------------------------------------------------------------------
# 起動オプション、設定ファイル読み込み
# --------------------------------------------------------------------

# -- コマンドオプション設定
my %options;
if($ARGV[0] ne 'cli') {
	# -- cli の時は `genie cli ls -la` などの引数をそのまま渡したいので無効に。
	GetOptions(
		'mode|m=s'      => \$config{GENERAL}->{runmode},
		'config|c=s'    => \$config{GENERAL}->{config_file},
		'all'           => \$options{all}, # specやdlsyncで使用
		'now-branch'    => \$options{'now-branch'}, # dlsyncで使用
		'oldest-branch' => \$options{'oldest-branch'}, # dlsyncで使用
		'cap'           => \$options{'cap'}, # specで使用
		'fast'          => \$options{'fast'}, # specで使用
	);
}

# -- .genieディレクトリがあるパスまで登って移動する
my $now_path = Cwd::getcwd();
my @dirs = split('/', $now_path);
while(@dirs){
	my $genie_path = join('/', @dirs);
	if(-d "$genie_path/$config_dir_name") {
		$config{GENERAL}->{home_dir} = $genie_path;
		$config{GENERAL}->{config_dir} = "$genie_path/$config_dir_name";
		chdir $genie_path;
		last;
	}
	pop @dirs;
}

# -- 見つからなければカレントを設定
$config{GENERAL}->{home_dir}   ||= $now_path;
$config{GENERAL}->{config_dir} ||= "$now_path/$config_dir_name";

# -- ランモード、設定ファイルの決定
$config{GENERAL}->{runmode} ||= 'develop';    # 未指定の場合 `develop` として動作します。または、compose実行の場合はproductになります。
$config{GENERAL}->{config_file} ||= "$config{GENERAL}->{config_dir}/config.pl"; # 未指定の場合 `.genie/config.pl` を読み込みます。
# echo "  Run `$config{GENERAL}->{runmode}` mode by `$config{GENERAL}->{config_file}`\n\n";

# -- 表示用にUTF8フラグ付きも用意しておく
$config{GENERAL_U}->{home_dir}    = Encode::decode(($is_win ? 'cp932' : 'utf-8'), $config{GENERAL}->{home_dir});
$config{GENERAL_U}->{config_dir}  = Encode::decode(($is_win ? 'cp932' : 'utf-8'), $config{GENERAL}->{config_dir});
$config{GENERAL_U}->{config_file} = Encode::decode(($is_win ? 'cp932' : 'utf-8'), $config{GENERAL}->{config_file});

# -- 設定ファイルをロード
if( -d $config{GENERAL}->{config_dir} ){
	if(-f $config{GENERAL}->{config_file}) {
		my $r = require $config{GENERAL}->{config_file};
		%config = (%config, %$r);
	} else {
		throw("設定ディレクトリ（$config{GENERAL_U}->{config_dir}）はあるのに設定ファイル（$config{GENERAL_U}->{config_file}）が見つかりません。");
	}
} else {
	unless($ARGV[0] eq '' || $ARGV[0] =~ /^(?:$noconf_args)$/){
		throw("設定ディレクトリが先祖パスに見つかりません。`genie init`をお忘れではないですか？");
	}
}

# -- データベース設定でLABELが重複していないか確認
foreach my $db_type (qw|MYSQL POSTGRESQL|) {
	my @err;
	my %book;
	map { if($book{$_->{LABEL}}++){push @err, $_->{LABEL};} } @{$config{$db_type}->{DATABASES}};
	throw("${db_type}の設定で、重複するラベルがあります。", join("\n", @err)) if @err;
}

# --------------------------------------------------------------------
# Dockerマシーン環境用意
# ※設定がされていたら。
# --------------------------------------------------------------------

# -- docker-machineコマンドが存在してるかどうか
`docker-machine`;
my $is_docker_machine = !$?;

# -- MACHINE名が未指定でも環境変数に入っていればセット
$config{DOCKER}->{MACHINE} ||= $ENV{DOCKER_MACHINE_NAME};

# -- ホストIPを設定
if($config{DOCKER}->{HOST_IP_FORCE}){
	$config{GENERAL}->{host_ip} = $config{DOCKER}->{HOST_IP_FORCE};
} else {
	if($is_docker_machine && $config{DOCKER}->{MACHINE}) {
		my $ip = `docker-machine ip $config{DOCKER}->{MACHINE}`;
		chomp $ip;
		$config{GENERAL}->{host_ip} = $ip;
	} else {
		$config{GENERAL}->{host_ip} = '127.0.0.1';
	}
}

# -- Dockerマシーンが指定されていれば切り替える
if($is_docker_machine && $config{DOCKER}->{MACHINE} ne '') {
	# -- docker-machine起動
	my $cmd = 'docker-machine start ' . $config{DOCKER}->{MACHINE}. ' ' . $hide_err;
	my $result = `$cmd`;
	if(!$?) {
	 	if($result !~ /^Starting/) {
			throw('Dockerマシンの起動に失敗しました。', $cmd);
	 	}
	} else {
		# -- docker-machineの環境切り替え
		$cmd = 'docker-machine env ' . $config{DOCKER}->{MACHINE} . ' ' . $hide_err;
		foreach my $line (split(/[\r\n]+/, `$cmd`)) {
			if($line =~ /(DOCKER_\w+)\s*\=\s*\"?([^\"]+)\"?/) {
				$ENV{$1} = $2;
			}
		}
	}
}

# --------------------------------------------------------------------
# 処理分け
# --------------------------------------------------------------------

# -- 追加コマンドの指定があればそっちを実行
if($config{ADD_COMMAND} && keys %{$config{ADD_COMMAND}}){
	if($config{ADD_COMMAND}->{$ARGV[0]} ne '') {
		exit 1 unless require_up(); # 起動必須
		my @args = @ARGV;
		shift @args;
		my $in_cmd = $config{ADD_COMMAND}->{$ARGV[0]} . ' ' . join(' ', @args);
		$in_cmd =~ s/\"/\\\"/g;
		my $cmd = "docker exec -ti $config{DOCKER}->{NAME} sh -c \"$in_cmd\"";

		# -- genie正常完了
		exit system($cmd);
	}
}

print "\n";

# -- 正しい第一引数かチェック
if($ARGV[0] !~ /^(?:$ok_args)$/) {
	help();
	exit 0;
}

# -- 第一引数により関数にジャンプ
if( $ARGV[0] =~ /^(?:$ok_args)$/ ){
	no strict;
	$ARGV[0]->();

	# -- 経過時間
	my $elapsed_time = '.';
	if($start_time) {
		my $sec = gettimeofday-$start_time;
		$elapsed_time = sprintf(' in %02d:%02d:%05.2f',
			int($sec/3600),
			int(($sec-int($sec/3600))/60),
			$sec-int(($sec-int($sec/3600))/60),
		);
	}

	# -- 終了処理
	style(color=>'black', bgcolor=>'dark_black');
	echo "  * Finished$elapsed_time\n\n";
	style(color=>'clear', bgcolor=>'clear');

	# -- genie正常完了
	exit 0;
}

# -- ヘルプ表示
help();

exit 0;

# --------------------------------------------------------------------
# コマンド引数ヘルプ表示
# --------------------------------------------------------------------

sub help {

	my $helps = [
		{
			label  => "OPTIONS",
			list   => [
				'-m|--mode <mode>'   => '実行モード（developまたはproduct）を指定（default: 標準）',
				'-c|--config <file>' => '設定ファイルを指定（default: .genie/config.pl）',
			],
		},
		{
			label  => "GENERAL\nCOMMANDS",
			list   => [
				'init <branch>'   => '同ディレクトリに.genieディレクトリを作成',
				'update <branch>' => '本体の更新、及び.genieディレクトリを更新',
				'up'              => '起動 - コンテナを作成、起動済みなら再起動',
				'down'            => '終了 - コンテナ削除',
				'config'          => '設定内容の確認',
				'config open'     => '設定ファイル(config.pl)を標準エディタで開く',
				'cli'             => 'genieコンテナのCLIにログイン',
				'cli <command>'   => 'genieコンテナ上で指定コマンド<command>実行',
				'ls'              => 'docker情報を一挙に表示',
				'reject'          => 'genie管理外のdockerコンテナも全て強制削除した後、clean実行',
				'clean'           => '終了済みコンテナ、<none>イメージ、未参照のDataVolumeの削除',
				'clean locked'    => '`locked`から始まるDataVolumeも削除',
				'clean product'   => '`product`から始まるDataVolumeも削除',
				'php'             => 'PHPの指定可能なバージョンリストと現在のphpenv選択バージョンの表示',
				'perl'            => 'Perlの指定可能なバージョンリストと現在のperlenv選択バージョンの表示',
				'ruby'            => 'Rubyの指定可能なバージョンリストと現在のrubyenv選択バージョンの表示',
				'build'           => 'config.pl指定のIMAGE名でビルド実行',
				'build nocache'   => 'config.pl指定のIMAGE名でキャッシュを使用せずにビルド実行',
				'demo'            => 'デモモード',
			],
		},
		{
			label => "DATABASE\nCOMMANDS\n(default\n num=1)",
			list  => [
				'mysql <num>'         => 'MySQLコンテナのmysqlに入る（<num>で設定番号指定可）',
				'mysql ls'            => 'MySQLの設定番号を確認する',
				'mysql cli <num>'     => 'MySQLコンテナのbashに入る（<num>で設定番号指定可）',
				'mysql dump <num>'    => 'MySQLのダンプを取る（<num>で設定番号指定可）',
				'mysql restore <num>' => 'MySQLのリストアを行う（<num>で設定番号指定可）',
				'psql <num>'          => 'PostgreSQLコンテナのpsqlに入る（<num>で設定番号指定可）',
				'psql ls'             => 'PostgreSQLの設定番号を確認する',
				'psql cli <num>'      => 'PostgreSQLコンテナのbashに入る（<num>で設定番号指定可）',
				'psql dump <num>'     => 'PostgreSQLのダンプを取る（<num>で設定番号指定可）',
				'psql restore <num>'  => 'PostgreSQLのリストアを行う（<num>で設定番号指定可）',
			],
		},
		{
			label => "DEVELOP\nCOMMANDS",
			list  => [
				'open'                     => 'ブラウザを開く',
				'ngrok'                    => 'ngrok起動',
				'logs'                     => 'ログファイルをtailする',
				'dlsync <timing of later>' => 'FTPサーバからファイルをダウンロード同期：引数無しでヘルプ表示',
				'httpd'                    => '実行パス位置でhttpdを立ち上げ（設定ファイルいらず）',
				'spec <feature dir/files>' => 'Capybaraを使用したSPECテストを実行：引数無しでヘルプ表示',
				'spec --all'               => 'Capybaraを使用したSPECテストを全て実行',
				'spec --all --cap'         => '自動的にキャプチャを録ります',
				'spec --all --fast'        => '起動中のコンテナ上でSPEC実行',
				'zap <port/schema/url>'    => 'OWASP/ZAPコンテナを起動して脆弱性をチェック：引数無しでヘルプ表示',
			],
		},
	];

	# -- 追加サブコマンド用のヘルプ追加
	if( ref $config{ADD_COMMAND} && %{$config{ADD_COMMAND}} ) {
		my $list = [];
		foreach(keys %{$config{ADD_COMMAND}}) {
			push @$list, $_ => $config{ADD_COMMAND}->{$_};
		}
		if(scalar(@$list)<3) { push @$list, '' }
		push @$helps, {
			label => "ADD\nCOMMANDS",
			list  => $list,
		};
	}

	my $label_width   = 10;
	my $command_width = 25;

	echo "\n";
	echo &gray_brace("Usage: genie [command] <options>\n");
	foreach my $help (@{$helps}) {
		echo "\n";
		my @label_line = split("\n", $help->{label});
		my @list = @{$help->{list}};
		my $count = 0;
		while(@list){
			echo sprintf("\x1b[36m%-".$label_width."s\x1b[0m | ", $label_line[$count++]);
			my($command, $desc) = splice(@list, 0, 2);
			my $before_command = $command;
			$command = &gray_brace($command);
			echo sprintf("%-".($command_width+(length($command)-length($before_command)))."s%s\n", $command, $desc);
		}
	}
	echo "\n";
}

# -- <>で囲まれた箇所をグレー表示にする
sub gray_brace {
	my $str = shift;
	$str =~ s/(\<.+\>)/\x1b[90m$1\x1b[0m/g;
	return $str;
}

# --------------------------------------------------------------------
# ヘルパー関数
# --------------------------------------------------------------------

# メッセージ表示ヘルパー
# ----------------------
sub message {
	my ($type, $message, $line) = @_;
	my @messages = split(/[\r\n]+/, $message);
	my %style;
	my %clear = (color=>'clear', bgcolor=>'clear', weight=>'clear', decoratiinfo=>'clear');
	
	   if($type eq 'default' ) { %style = (color=>'dark_white'); }
	elsif($type eq 'primary' ) { %style = (color=>'blue'); }
	elsif($type eq 'success' ) { %style = (color=>'green'); }
	elsif($type eq 'info'    ) { %style = (color=>'cyan'); }
	elsif($type eq 'warning' ) { %style = (color=>'yellow'); }
	elsif($type eq 'danger'  ) { %style = (color=>'red'); }
	elsif($type eq 'disabled') { %style = (color=>'black'); }

	my $width;
	foreach(@messages) {
		my $len = length Encode::encode('cp932', $_);
		if($width<$len) { $width = $len; }
	}
	style(%style);

	echo '  +' . ('-' x ($width+2)) . "+\n";
	my $count;
	foreach(@messages) {
		my $len = length Encode::encode('cp932', $_);
		echo '  | ';
		echo $_;
		echo ' ' x ($width==$len ? 0 : $width-$len);
		echo " |\n";
		if(++$count==$line) {
			echo '  +' . ('-' x ($width+2)) . "+\n";
		}
	}
	echo '  +' . ('-' x ($width+2)) . "+\n";
	style(%clear);
	print "\n";
}

# カラーセットヘルパー
# --------------------
# style(
# 	color      => 'red',
# 	bgcolor    => 'blue',
# 	weight     => 'bold',
# 	decoration => 'undeline',
# );
sub style {
	my %style = @_;
	my($color, $bgcolor) = @_;
	my %colors = (
		black        => "\x1b[90m", dark_black   => "\x1b[30m",
		red          => "\x1b[91m", dark_red     => "\x1b[31m",
		green        => "\x1b[92m", dark_green   => "\x1b[32m",
		yellow       => "\x1b[93m", dark_yellow  => "\x1b[33m",
		blue         => "\x1b[94m", dark_blue    => "\x1b[34m",
		magenta      => "\x1b[95m", dark_magenta => "\x1b[35m",
		cyan         => "\x1b[96m", dark_cyan    => "\x1b[36m",
		white        => "\x1b[97m", dark_white   => "\x1b[37m",
		clear        => "\x1b[39m",
	);
	my %bgcolors = (
		black        => "\x1b[100m", dark_black   => "\x1b[40m",
		red          => "\x1b[101m", dark_red     => "\x1b[41m",
		green        => "\x1b[102m", dark_green   => "\x1b[42m",
		yellow       => "\x1b[103m", dark_yellow  => "\x1b[43m",
		blue         => "\x1b[104m", dark_blue    => "\x1b[44m",
		magenta      => "\x1b[105m", dark_magenta => "\x1b[45m",
		cyan         => "\x1b[106m", dark_cyan    => "\x1b[46m",
		white        => "\x1b[107m", dark_white   => "\x1b[47m",
		clear        => "\x1b[49m",
	);
	my %weight = (
		bold    => "\x1b[1m",
		clear   => "\x1b[0m",
	);
	my %decoration = (
		underline => "\x1b[4m",
		clear     => "\x1b[0m",
	);
	my $set = '';
	$set .= $colors{$style{color}} ? $colors{$style{color}} : '';
	$set .= $bgcolors{$style{bgcolor}} ? $bgcolors{$style{bgcolor}} : '';
	$set .= $weight{$style{weight}} ? $weight{$style{weight}} : '';
	$set .= $decoration{$style{decoration}} ? $decoration{$style{decoration}} : '';
	print $set if $set;
}

# コンテナが起動しているか確認するヘルパー
# ----------------------------------------
# 引数未指定の場合はkazaoki/genieのコンテナ名
sub is_up {
	my $container_name = shift;
	my $cmd = 'docker top ' . ($container_name || $config{DOCKER}->{NAME});
	`$cmd $hide_all`;
	return !$?;
}

# コンテナが存在しているか確認するヘルパー
# ----------------------------------------
# 起動してなくても存在さえしていれば１を返す
sub is_exist {
	my $container_name = shift;
	my $cmd = 'docker inspect ' . ($container_name || $config{DOCKER}->{NAME});
	`$cmd $hide_all`;
	return !$?;
}

# 起動してない場合はエラーを表示するヘルパー
# ------------------------------------------
sub require_up {
	if(!is_up()) {
		message(warning=>'起動してません：' . $config{DOCKER}->{NAME});
		return;
	}
	return 1;
}

# データ入力ヘルパー
# ------------------
sub input {
	my $string = shift;
	my $tail_space = shift || 5;
	my $len = (length Encode::encode('cp932', $string)) + 2 + $tail_space;

	# -- 末尾だと崩れるので少し行送りしてカーソルを戻る
	print "\n" x 4;
	print "\e[4A";
	
	# -- 描画開始
	style(color=>'white', bgcolor=>'blue');
	echo ' ' x $len . "\n";
	echo "  $string".(' 'x$tail_space)."\n";
	echo ' ' x $len . "\n";
	style(color=>'white', bgcolor=>'dark_blue');
	echo ' ' x $len . "\n";
	style(color=>'white', bgcolor=>'blue');
	echo "\e[3A\e[".($len-$tail_space)."C";

	# -- 発言
	say('入力して下さい');

	# -- 入力
	my $input = <STDIN>;

	# -- 開始時間リセット
	$start_time = gettimeofday;

	# -- クリアして終わり
	echo "\e[2B";
	style(color=>'clear', bgcolor=>'clear');
	return decode('sjis', $input);
}

# エラー終了ヘルパー
# ------------------
sub throw {
	my($message, $detail) = @_;
	print "\n";
	if($detail) {
		message(danger=>"$message\n$detail", scalar(split(/\n/, $message)));
	} else {
		message(danger=>$message);
	}
	exit 1;
}

# スピーチヘルパー
# ----------------
sub say {
	return if $config{DOCKER}->{NO_SAY};

	# -- 音声無理ならベルだけ鳴らす
	if(!$can_say){
		print "\a";
		return 1;
	}

	my $message = encode($is_win ? 'Shift_JIS' : 'UTF-8', shift);
	# -- for Mac
	if($is_mac) {
	    system "say -r 300 \"$message\"";
	}
	# -- for Windows
	elsif ($is_win) {

		# -- テンポラリフォルダに _genie_say.js 用意
		my $temp_path = `echo %temp%`;
		chomp $temp_path;
		my $say_js = "$temp_path\\_genie_say.js";
		if(!-e $say_js){
			open my $fh, ">$say_js";
			print $fh q|var args = [];for(var i = 0; i < WScript.Arguments.length; i++) args.push(WScript.Arguments.Item(i));WScript.CreateObject('SAPI.SpVoice').Speak('<volume level="100">'+'<rate speed="2">'+'<pitch middle="0">'+args.join(' ')+'</pitch>'+'</rate>'+'</volume>', 8);|;
			close $fh;
		}

		# -- 音声出力
		system "start wscript $say_js \"$message\"";
	}
}

# 使用中のデータボリューム名を返す
# --------------------------------
sub get_data_volume_name {
	my $container_name = shift;
	my @volumes;
	my @lines = `docker inspect --format='{{.Mounts}}' $container_name $hide_err` =~ /\{\s*([^\{\}]+)\s*\}/g;
	foreach(@lines){
		if( $_=~/^(.+?) / && $1!~/\// ) {
			push @volumes, $1;
		}
	}
	return @volumes;
}

# 指定コンテナの内部IPを返す
# --------------------------
sub get_container_ip {
	my $container_name = shift;
	my $ip = `docker inspect --format='{{.NetworkSettings.IPAddress}}' $container_name $hide_err`;
	chomp $ip;
	return $ip;
}

# コンテナ側処理をプログレスを表示しながら待つ
# --------------------------------------------
# [例]
# &wait_container(
#     container_name => 'genie-test',
#     log_file       => '/var/log/apache.log',
#     proc_command   => 'entrypoint.sh',
#     stop_word      => 'done',
#     label          => 'Start',
#     label_head     => ' ',   # default '  | '
#     progress_char  => '+',   # default '.'
#     result_ok      => ' ok', # default ' OK'
#     result_ng      => ' ng', # default ' NG'
#     sleep_sec      => 5,     # default 1
# );
# `container_name`コンテナ内の`log_file`に`stop_word`が見つかるまでループします。
# ※log_file未指定の場合は、標準出力(docker logs)の値から探します。
# ※proc_commandが指定されてた場合は、ログファイルや標準出力ではなく、psコマンドで指定のコマンドが終了して消えるまでループします。
sub wait_container {
	my $param = shift;
	# -- コンテナ名チェック
	if(!$param->{container_name}){
		throw('コンテナ名が指定されていません。');
	}
	if(!is_up($param->{container_name})){
		throw("指定のコンテナ `$param->{container_name}` に接続出来ませんでした。")
	}
	# -- 停止ワードチェック（proc_commandが指定されている場合は不必要）
	if((!$param->{proc_command}) && !$param->{stop_word}){
		throw('停止ワードが指定されていません。');
	}
	# -- デフォルト値セット
	$param->{label}         = (defined $param->{label}        ) ? $param->{label}         : '';
	$param->{label_head}    = (defined $param->{label_head}   ) ? $param->{label_head}    : '  | - ';
	$param->{progress_char} = (defined $param->{progress_char}) ? $param->{progress_char} : '.';
	$param->{result_ok}     = (defined $param->{result_ok}    ) ? $param->{result_ok}     : 'OK';
	$param->{result_ng}     = (defined $param->{result_ng}    ) ? $param->{result_ng}     : 'NG';
	$param->{sleep_sec}     = (defined $param->{sleep_sec}    ) ? $param->{sleep_sec}     : 1;

	# -- ラベル表示
	echo "$param->{label_head}$param->{label} ";

	my $error;
	my $loop = 1;
	my $progress_count = 0;

	# -- チェック用コマンド用意
	my $cmd;
	if($param->{log_file}) {
		# -- ログファイルをチェックするコマンド
		$cmd = qq|docker exec $param->{container_name} sh -c "cat $param->{log_file} 2>/dev/null \| grep '$param->{stop_word}' \| wc -l"|;
	} elsif($param->{proc_command}) {
		# -- プロセスから指定コマンドが消えているかチェックするコマンド
		$cmd = qq/docker exec $param->{container_name} sh -c "ps aux|grep $param->{proc_command}|grep -v grep|wc -l"/;
	} else {
		# -- 標準出力をチェックするコマンド
		$cmd = qq|docker logs $param->{container_name} 2>&1|;
	}
		
	do {
		# -- 生存確認
		if(is_up($param->{container_name})){
			# -- ログファイルをチェック
			if($param->{log_file}) {
				my $hit_count = `$cmd`;
				chomp $hit_count;
				if($hit_count) {
					undef $loop;
				} else {
					echo $param->{progress_char};
					$progress_count ++;
					sleep $param->{sleep_sec};
				}
			}
			# -- プロセスから指定コマンドが消えているかチェック
			elsif($param->{proc_command}) {
				my $hit_count = `$cmd`;
				chomp $hit_count;
				if(!$hit_count) {
					undef $loop;
				} else {
					echo $param->{progress_char};
					$progress_count ++;
					sleep $param->{sleep_sec};
				}
			}
			# -- 標準出力をチェック
			else {
				my $log = `$cmd`;
				$log = decode('UTF-8', $log);
				if(grep { index($_, $param->{stop_word})!=-1 } split(/[\r\n]+/, $log)) {
					undef $loop;
				} else {
					echo $param->{progress_char};
					$progress_count ++;
					sleep $param->{sleep_sec};
				}
			}
		} else {
			# -- コンテナが死んでる場合
			$error = `docker logs $param->{container_name} 2>&1`;
			$error ||= 'コンテナが削除された可能性があります。';
			undef $loop;
		}
	} while($loop);

	# -- 完了表示
	if(!$error){
		# -- 成功
		style(color=>'green');
		if($progress_count) { print ' '; }
		echo "$param->{result_ok}";
		style(color=>'clear');
	} else {
		# -- エラー
		style(color=>'red');
		echo " $param->{result_ng}";
		style(color=>'clear');
		my @lines = split(/[\r\n]+/, $error);
		if(scalar(@lines) > 10 ) {
			@lines = splice(@lines, -10, 10); # エラーメッセージが110行以上なら最後から10行のみ表示
		}
		print "\n";
		message(danger=>join("\n", @lines));
	}

	print "\n";

	return;
}

# 文字列から引数をリストリファレンスとして返す
# --------------------------------------------
# [例] : my $list_ref = &args_to_list('-p', '-p 123:123 -p "555 666"'); # -> ['123:123', '555 666']
# [例] : my $list_ref = &args_to_list('--add-host', '--add-host="hogehoge:127.0.0.2"'); # -> ['hogehoge:127.0.0.2']
sub args_to_list($$) {
	my ($string, $key) = @_;
	my $list = [map { $_ =~ s/['"]//g; $_ } $string =~ /$key[\s\=]\s*([^\s"]*["][^"]+?["]|[^\s']*['][^']+?[']|[^'"\s]+)/g];
	return $list;
}

# --------------------------------------------------------------------
# genie init <branch>                                           初期化
# --------------------------------------------------------------------
# genie init develop でdevelopブランチの.genieを持ってきます。
sub init {

	# -- 設定ディレクトリの存在確認
	if(-d $config{GENERAL}->{config_dir}) {
		throw("設定ディレクトリが既にあるので処理を中止します。\n既存の設定を更新したい場合は `genie update <branch>` を使用して下さい。", $config{GENERAL_U}->{config_dir});
	}

	# -- ブランチ指定
	my $branch = $ARGV[1] ne '' ? $ARGV[1] : 'master';

	# -- コマンド実行
	my $cmd = "docker run --rm -v $config{GENERAL}->{home_dir}:/work -e GENIE_PROC=init -e GENIE_INIT_BRANCH=$branch kazaoki/genie";

	system $cmd;
	if($?){
		rmdir $config_dir_name;
		throw 'init に失敗しました。';
	}

	# -- Windowsの場合、隠しフォルダに。
	if($is_win){
		`attrib +h $config_dir_name`;
	}

	print "\n";
	message(success=>"設定ファイルを作成しました。\n".$config{GENERAL_U}->{config_dir}, 1);

	# -- configをエディタで開く
	if($open_cmd){
		`$open_cmd $config{GENERAL}->{config_file} $open_cmd_after`;
	}

	return 1;

}

# --------------------------------------------------------------------
# genie update <branch>                      最新のgenieにアップデート
# --------------------------------------------------------------------
# genie update develop でdevelopブランチの.genieを対象にする
sub update {

	# -- 確認する
	message(warning=>
		"【ご注意】\n".
		"・updateは、genie本体（共通1箇所）と現在直近の .genie ディレクトリを更新します。\n".
		"・設定ファイルはGitHub上の初期ファイルに全て上書きされますので、既存の設定は消えます。\n".
		"・設定ファイルはgitなどでバージョン管理をし、必要箇所を戻すなどしてご利用下さい。\n"
	, 1);
	my $input = input("c=設定ファイル群(.genie/)を更新 / g=本体（genie）を更新 / y=両方更新 [c/g/y/N]: ");
	return if $input !~ /^(?:[cgy])$/i;

	# -- ブランチ指定
	my $branch = $ARGV[1] ne '' ? $ARGV[1] : 'master';

	# -- 一時コンテナを起動してそっちで設定ファイルコピーしてくる
	if($input =~ /^[cy]$/i ) {
	
		# -- 設定ディレクトリの存在確認
		if(!-d $config{GENERAL}->{config_dir}) {
			message(danger=>"$config{GENERAL_U}->{config_dir} ディレクトリがありません。先に init を実行してください。");
			return;
		}

		# -- コンテナ起動
		my $cmd = "docker run --rm -v $config{GENERAL}->{home_dir}:/work -e GENIE_PROC=update -e GENIE_UPDATE_BRANCH=$branch $config{DOCKER}->{IMAGE}";
		system $cmd;
		if($?){
			message(danger=>'update に失敗しました。');
			return;
		}
		print "\n";
		message(success=>"設定ファイルを上書きしました。\n".$config{GENERAL_U}->{config_dir}, 1);
	}

	# -- genie本体の更新
	if($input =~ /^[gy]$/i ) {
		my $data = encode('UTF-8', get("https://raw.githubusercontent.com/kazaoki/genie/$branch/cmd/genie"));
		if(!$data) { throw 'ダウンロードに失敗した可能性があります。(genie)'; }
		open my $fh, '>', __FILE__ or die $!;
		binmode $fh;
		print $fh $data;
		close $fh;
		if($is_win){
			my $data = encode('UTF-8', get("https://raw.githubusercontent.com/kazaoki/genie/$branch/cmd/genie.cmd"));
			if(!$data) { throw 'ダウンロードに失敗した可能性があります。(genie.cmd)'; }
			open my $fh, '>', __FILE__.'.cmd' or die $!;
			binmode $fh;
			print $fh $data;
			close $fh;
		}
		print "\n";
		message(success=>"genie本体を上書きしました。\n".__FILE__.($is_win ? "\n".__FILE__.'.cmd' : ''), 1);
	}

	return 1;

}

# --------------------------------------------------------------------
# genie demo                                                      デモ
# --------------------------------------------------------------------
sub demo {

	# -- カラーメッセージBOX
	foreach(qw/default primary success info warning danger disabled/) {
		message($_=>$_);
	}
	message(warning=>"複数行も\n可能です!!");
	message(default=>"1箇所なら\nライン入れも\n可能であります。", 2);

	# -- 入力BOX
	my $input = input('入力BOX（入力文字を発音しますのでご注意）：', 20);
	print "\n";
	message(default=>"入力された文字：$input");

	# -- sayテスト
	say($input);

	# -- エラー終了
	throw('エラーテスト', '終了ステータス1で終わります');
}

# --------------------------------------------------------------------
# genie up                                                起動・再起動
# --------------------------------------------------------------------
sub up {

	# -- 起動タイプ（spec, zap, compose）
	my $up_type = shift;
	my $container_name_base = ($up_type =~ /^(?:spec|zap)$/ ? uc($up_type).'-' : '') . $config{DOCKER}->{NAME};

	# -- 起動時メモの表示
	if(ref $config{UPMEMO}) {
		my @memolist = @{$config{UPMEMO}};
		while(@memolist){
			my $key = shift @memolist;
			my $value = decode('UTF-8', shift @memolist);
			message($key=>$value);
		}
	}

	# -- 既存のシステムを終了させる
	down($up_type);

	# -- 起動
	echo "  Starting ".($up_type ? uc($up_type).' ' : '')."containers\n" if $up_type ne 'compose';

	# -- MySQL起動
	my $mysql_option;
	my $mysql_last_label; # 最後に起動したコンテナを起動プログレス表示に使用
	if($config{MYSQL}->{ENABLED}) {
		# -- スクリプトパーミッション設定
		chmod 0755, "$config{GENERAL}->{config_dir}/mysql/opt/before-entrypoint.sh";
		# -- コンテナ起動
		foreach my $db (@{$config{MYSQL}->{DATABASES}}) {
			my $label = $container_name_base . "-mysql-" . $db->{LABEL};
			$mysql_last_label = $label;
			my $cmd =
				"docker run -d -it --name $label".
				" -v $config{GENERAL}->{config_dir}/mysql:/mysql".
				($up_type =~ /^(?:spec|zap)$/ ? '' : " -v ".(($up_type ne 'compose' && $db->{DATA_VOLUME_LOCK}) ? 'locked_' : '')."$label:/var/lib/mysql").
				" -e MYSQL_LABEL=$db->{LABEL}".
				" -e MYSQL_ROOT_PASSWORD=$db->{PASS}".
				" -e MYSQL_DATABASE=$db->{NAME}".
				" -e MYSQL_USER=$db->{USER}".
				" -e MYSQL_PASSWORD=$db->{PASS}".
				" -e MYSQL_CHARSET=$db->{CHARSET}".
				" -e TERM=xterm".
				($db->{HOST} ? " --add-host=$db->{HOST}:127.0.0.1" : '' ).
				(ref $db->{BIND_PORTS} ? join('', map { " -p $_" } @{$db->{BIND_PORTS}}) : '' ).
				" --entrypoint=/mysql/opt/before-entrypoint.sh".
				' --restart=always'.
				" $db->{REPOSITORY}".
				" mysqld"
			;

			if($up_type eq 'compose'){

				# -- compose用情報収集
				$comp->{services}->{"$config{DOCKER}->{NAME}-mysql-$db->{LABEL}"} = {
					image       => $db->{REPOSITORY},
					environment => &args_to_list($cmd, '-e'),
					ports       => &args_to_list($cmd, '-p'),
					volumes     => &args_to_list($cmd, '-v'),
					extra_hosts => &args_to_list($cmd, '--add-host'),
					entrypoint  => ['/mysql/opt/before-entrypoint.sh'],
					command     => ['mysqld'],
					restart     => 'always',
				};
				$comp->{volumes}->{$label} = {driver=>'local'};

			} else {

				# -- 起動タイプの引数調整
				if($up_type) {
					# -- ポートバインドを消す
					$cmd =~ s/ \-p [^ ]+//g;
				}

				# -- コンテナ実行
				`$cmd`;

				# -- 起動開始のプログレス
				wait_container ({
					container_name => $label,
					log_file       => '/var/log/init.log',
					stop_word      => 'Process start',
					label          => "MySQL container start ($label)",
				});

				# -- コンテナ直下に起動用コマンドを記録する（restore用）
				`docker exec $label sh -c "echo '$cmd' > /docker-run.cmd"`;
			}


			# -- 本体からリンクするための情報
			if($up_type) {
				my $label_raw = $label;
				$label_raw =~ s/^$up_type-//i;
				$mysql_option .= " --link $label:$label_raw";
			} else {
				$mysql_option .= " --link $label";
			}

			# -- HOST情報をセット
			if($db->{HOST}) {
				$mysql_option .= ' --add-host='.$db->{HOST}.':'.get_container_ip($label);
			}

		}
	}

	# -- PostgreSQL起動
	my $postgresql_option;
	my $postgresql_last_label; # 最後に起動したコンテナを起動プログレス表示に使用
	if($config{POSTGRESQL}->{ENABLED}) {
		# -- スクリプトパーミッション設定
		chmod 0755, "$config{GENERAL}->{config_dir}/postgresql/opt/before-entrypoint.sh";
		# -- コンテナ起動
		foreach my $db (@{$config{POSTGRESQL}->{DATABASES}}) {
			my $label = $container_name_base . "-postgresql-" . $db->{LABEL};
			$postgresql_last_label = $label;
			my $cmd =
				"docker run -d -it --name $label".
				" -v $config{GENERAL}->{config_dir}/postgresql:/postgresql".
				($up_type =~ /^(?:spec|zap)$/ ? '' : " -v ".(($up_type ne 'compose' && $db->{DATA_VOLUME_LOCK}) ? 'locked_' : '')."$label:/var/lib/postgresql/data").
				" -e MYSQL_ROOT_PASSWORD=$db->{PASS}".
				" -e POSTGRES_LABEL=$db->{LABEL}".
				" -e POSTGRES_HOST=$db->{HOST}".
				" -e POSTGRES_DB=$db->{NAME}".
				" -e POSTGRES_USER=$db->{USER}".
				" -e POSTGRES_PASSWORD=$db->{PASS}".
				" -e POSTGERS_ENCODING=$db->{ENCODING}".
				" -e POSTGERS_LOCALE=$db->{LOCALE}".
				" -e TERM=xterm".
				(ref $db->{BIND_PORTS} ? join('', map { " -p $_" } @{$db->{BIND_PORTS}}) : '' ).
				" --entrypoint=/postgresql/opt/before-entrypoint.sh".
				' --restart=always'.
				" $db->{REPOSITORY}".
				" postgres"
			;

			if($up_type eq 'compose'){

				# -- compose用情報収集
				$comp->{services}->{"$config{DOCKER}->{NAME}-postgresql-$db->{LABEL}"} = {
					image       => $db->{REPOSITORY},
					environment => &args_to_list($cmd, '-e'),
					ports       => &args_to_list($cmd, '-p'),
					volumes     => &args_to_list($cmd, '-v'),
					extra_hosts => &args_to_list($cmd, '--add-host'),
					entrypoint  => ['/postgresql/opt/before-entrypoint.sh'],
					command     => ['postgres'],
					restart     => 'always',
				};
				$comp->{volumes}->{$label} = {driver=>'local'};

			} else {

				# -- 起動タイプの引数調整
				if($up_type) {
					# -- ポートバインドを消す
					$cmd =~ s/ \-p [^ ]+//g;
				}

				# -- コンテナ実行
				`$cmd`;

				# -- 起動開始のプログレス
				wait_container ({
					container_name => $label,
					log_file       => '/var/log/init.log',
					stop_word      => 'Process start',
					label          => "PostgreSQL container start ($label)",
				});

				# -- コンテナ直下に起動用コマンドを記録する（restore用）
				`docker exec $label sh -c "echo '$cmd' > /docker-run.cmd"`;
			}

			# -- 本体からリンクするための情報
			if($up_type) {
				my $label_raw = $label;
				$label_raw =~ s/^$up_type-//i;
				$postgresql_option .= " --link $label:$label_raw";
			} else {
				$postgresql_option .= " --link $label";
			}

			# -- HOST情報をセット
			if($db->{HOST}) {
				$postgresql_option .= ' --add-host='.$db->{HOST}.':'.get_container_ip($label);
			}

		}
	}

	# -- 本体の起動（Apache）
	{
		# -- 設定値を環境変数として渡す形(-e)に変換
		my %envs;
		my $make_envs;
		$make_envs = sub {
			my($var, $label) = @_;
			$label = uc $label;
			if(!ref $var) {
				$var =~ s/\"//g;
				if($envs{$label} ne '') {
					$envs{$label} .= ",$var";
				} else {
					$envs{$label} = $var;
				}
			}
			elsif(ref $var eq 'ARRAY') {
				my $count = 1;
				foreach(@{$var}){
					if(ref $_ eq 'HASH') {
						&$make_envs($_, "${label}_${count}");
					} else {
						&$make_envs($_, $label);
					}
					$count ++; # ハッシュアレイの場合、1から番号を振る
				}
			}
			elsif(ref $var eq 'HASH') {
				foreach(keys %{$var}){
					&$make_envs($var->{$_}, ($label ne '' ? "${label}_" : '').$_);
				}
			}
		};
		&$make_envs(\%config, 'GENIE');

		# -- dockerコンテナに送る環境変数引数を構築
		my $envs;
		foreach my $key (sort(keys %envs)){
			if($key =~ /^(?:GENIE_UPMEMO|GENIE_GENERAL_U_)/) { next ;} # 除外する環境変数名
			$envs .= ' ' if $envs ne '';
			$envs .= sprintf('-e %s="%s"', $key, $envs{$key});
		}

		# -- Apache
		my $apache_option;
		if($config{APACHE}->{ENABLED}) {
			$apache_option .= " -v $config{GENERAL}->{home_dir}/$config{APACHE}->{PUBLIC_PATH}:/var/www/html";
			if(ref $config{APACHE}->{BIND_PORTS}){
				foreach(@{$config{APACHE}->{BIND_PORTS}}){
					$apache_option .= " -p $_";
				}
			}
		}

		# -- Nginx
		my $nginx_option;
		if($config{NGINX}->{ENABLED}) {
			$nginx_option .= " -v $config{GENERAL}->{home_dir}/$config{NGINX}->{PUBLIC_PATH}:/usr/share/nginx/html";
			if(ref $config{NGINX}->{BIND_PORTS}){
				foreach(@{$config{NGINX}->{BIND_PORTS}}){
					$nginx_option .= " -p $_";
				}
			}
		}

		# -- Sendlog
		my $sendlog_option;
		if($config{SENDLOG}->{ENABLED}) {
			if(ref $config{SENDLOG}->{BIND_PORTS}){
				foreach(@{$config{SENDLOG}->{BIND_PORTS}}){
					$sendlog_option .= " -p $_";
				}
			}
		}

		# -- add hosts
		my $add_host;
		if(ref $config{DOCKER}->{HOSTS}) {
			foreach(@{$config{DOCKER}->{HOSTS}}){
				$add_host .= qq| --add-host="$_"|;
			}
		}

		# -- VOLUMES
		my $volumes;
		if(ref $config{DOCKER}->{VOLUMES} && @{$config{DOCKER}->{VOLUMES}}){
			foreach my $volume (@{$config{DOCKER}->{VOLUMES}}) {
				if($volume !~ /^\//){
					$volume = $config{GENERAL}->{home_dir} . '/' . $volume;
					$volumes .= " -v $volume";
				}
			}
		}

		# -- runコマンドの作成
		my $cmd =
			'docker run -d -it'.
			' -e TERM=xterm'.
			' -e LANG=ja_JP.UTF-8'.
			' -e LC_ALL=ja_JP.UTF-8'.
			($config{PERL}->{CPANFILE_ENABLED} ? ' -e PERL5LIB=/perl/cpanfile-modules/lib/perl5' : '').
			($options{cap} ? ' -e GENIE_SPEC_AUTOCAP=1' : '').
			" -v $config{GENERAL}->{config_dir}/genie:/genie".
			(-d "$config{GENERAL}->{config_dir}/spec" ? " -v $config{GENERAL}->{config_dir}/spec:/spec" : '').
			(-d "$config{GENERAL}->{config_dir}/spec" ? " -v $config{GENERAL}->{config_dir}/spec/confs:/turnip/spec" : '').
			$mysql_option.
			$postgresql_option.
			$apache_option.
			$nginx_option.
			$sendlog_option.
			$add_host.
			$volumes.
			" --name=$container_name_base".
			" $envs".
			($config{DOCKER}->{OPTIONS} ? " $config{DOCKER}->{OPTIONS}" : '').
			' --restart=always'.
			" $config{DOCKER}->{IMAGE}"
		;

		if($up_type eq 'compose'){

			# -- compose用情報収集
			$comp->{services}->{$container_name_base} = {
				image       => $config{DOCKER}->{IMAGE},
				environment => &args_to_list($cmd, '-e'),
				ports       => &args_to_list($cmd, '-p'),
				volumes     => &args_to_list($cmd, '-v'),
				extra_hosts => &args_to_list($cmd, '--add-host'),
				links       => &args_to_list($cmd, '--link'),
				restart     => 'always',
			};
			return 1;
		}

		# -- 起動タイプの引数調整
		if($up_type) {
			# -- ポートバインドを消す
			$cmd =~ s/( \-p \d+)\:\d+/$1/g;
			# -- 環境変数設定
			$cmd =~ s/ $config{DOCKER}->{IMAGE}$/ -e GENIE_PROC="$up_type" $config{DOCKER}->{IMAGE}/;
			# -- マウントを「/_/*」に変える（entrypoint.sh時に正式なディレクトリにコピーする）
			$cmd =~ s/( \-v [^ ]+\:)([^ ]+)/$1\/_$2/g;
			# -- /spec/captures/をマウントする
			if($up_type eq 'spec'){
				$cmd =~ s/ $config{DOCKER}->{IMAGE}$/ -v $config{GENERAL}->{config_dir}\/spec\/captures:\/spec\/captures $config{DOCKER}->{IMAGE}/;
			}
		}

		# -- スクリプトパーミッション設定
		chmod 0755, "$config{GENERAL}->{config_dir}/genie/opt/init.sh";

		# -- runコマンドの実行
		my $cid = `$cmd`;
		if($?){
			throw('genie本体の起動に失敗しました。');
		}
		$cid =~ /^(.{12})/;
		my $short_cid = $1;

		# -- 起動プログレスまとめ（各コンテナは並行処理なのでウェイト処理はここでまとめる）
		{

			# -- kazaoki/genie本体：起動開始
			wait_container ({
				container_name => $container_name_base,
				log_file       => '/var/log/entrypoint.log',
				stop_word      => 'entrypoint.sh setup start.',
				label          => "Genie container start ($container_name_base)",
			});

			# -- entrypoint.sh：Perl
			if($config{PERL}->{VERSION}){
				wait_container ({
					container_name => $container_name_base,
					log_file       => '/var/log/entrypoint.log',
					stop_word      => 'Perl setup done.',
					label          => "Perl setup (version $config{PERL}->{VERSION})",
				});
			}

			# -- entrypoint.sh：cpanfile
			if($config{PERL}->{CPANFILE_ENABLED}){
				wait_container ({
					container_name => $container_name_base,
					log_file       => '/var/log/entrypoint.log',
					stop_word      => 'cpanfile setup done.',
					label          => "cpanfile setup",
				});
			}

			# -- entrypoint.sh：PHP
			if($config{PHP}->{VERSION}){
				wait_container ({
					container_name => $container_name_base,
					log_file       => '/var/log/entrypoint.log',
					stop_word      => 'PHP setup done.',
					label          => "PHP setup (version $config{PHP}->{VERSION})",
				});
			}

			# -- entrypoint.sh：Ruby
			if($config{RUBY}->{VERSION}){
				wait_container ({
					container_name => $container_name_base,
					log_file       => '/var/log/entrypoint.log',
					stop_word      => 'Ruby setup done.',
					label          => "Ruby setup (version $config{RUBY}->{VERSION})",
				});
			}

			# -- entrypoint.sh：Apache
			if($config{APACHE}->{ENABLED}) {
				wait_container ({
					container_name => $container_name_base,
					log_file       => '/var/log/entrypoint.log',
					stop_word      => 'Apache setup done.',
					label          => "Apache setup",
				});
			}

			# -- entrypoint.sh：Nginx
			if($config{NGINX}->{ENABLED}) {
				wait_container ({
					container_name => $container_name_base,
					log_file       => '/var/log/entrypoint.log',
					stop_word      => 'Nginx setup done.',
					label          => "Nginx setup",
				});
			}

			# -- entrypoint.sh：Postfix
			if($config{POSTFIX}->{ENABLED}){
				wait_container ({
					container_name => $container_name_base,
					log_file       => '/var/log/entrypoint.log',
					stop_word      => 'Postfix setup done.',
					label          => "Postfix setup",
				});
			}

			# -- init.sh
			wait_container ({
				container_name => $container_name_base,
				log_file       => '/var/log/entrypoint.log',
				stop_word      => 'init.sh setup done.',
				label          => "init.sh setup",
			});

			# -- MySQL
			if($config{MYSQL}->{ENABLED}) {
				wait_container ({
					container_name => $mysql_last_label,
					proc_command   => 'entrypoint.sh',
					label          => 'MySQL ready',
				});
			}

			# -- PostgreSQL
			if($config{POSTGRESQL}->{ENABLED}) {
				wait_container ({
					container_name => $postgresql_last_label,
					proc_command   => 'entrypoint.sh',
					label          => 'PostgreSQL ready',
				});
			}

			# -- kazaoki/genie本体：起動完了
			wait_container ({
				container_name => $container_name_base,
				log_file       => '/var/log/entrypoint.log',
				stop_word      => 'entrypoint.sh setup done.',
				label          => "Genie container ready",
			});

			print "\n";
		}

		# -- コンテナの情報からブラウザを起動
		if($config{BROWSER}->{OPEN_AT_UPPED} && !$up_type){
			&open();
		}

	}
}

# --------------------------------------------------------------------
# genie down                                                      終了
# --------------------------------------------------------------------
sub down {

	# -- 起動タイプ
	my $up_type = shift;

	# -- 対象コンテナピックアップ
	my @exist_containers;
	my $container_name_base = ($up_type ? uc($up_type).'-' : '') . $config{DOCKER}->{NAME};

	# -- 参照ボリューム名
	my @volumes;

	# -- MySQL
	if(ref $config{MYSQL}->{DATABASES}) {
		foreach(@{$config{MYSQL}->{DATABASES}}){
			my $label = $container_name_base . "-mysql-" . $_->{LABEL};
			if(is_exist($label)){
				push @exist_containers, $label;
				push @volumes, &get_data_volume_name($label);
			}
		}
	}

	# -- PostgreSQL
	if(ref $config{POSTGRESQL}->{DATABASES}) {
		foreach(@{$config{POSTGRESQL}->{DATABASES}}){
			my $label = $container_name_base . "-postgresql-" . $_->{LABEL};
			if(is_exist($label)){
				push @exist_containers, $label;
				push @volumes, &get_data_volume_name($label);
			}
		}
	}

	# -- genie本体
	if(is_exist($container_name_base)){
		push @exist_containers, $container_name_base;
		push @volumes, &get_data_volume_name($container_name_base);
	}

	# -- コンテナ削除開始
	if(@exist_containers) {
		style(color=>'black', bgcolor=>'dark_black');
		echo "  Deleting exist \"".($up_type ? uc($up_type).'-':'')."$config{DOCKER}->{NAME}*\" ".($up_type ? uc($up_type).' ' : '')."container".(scalar(@exist_containers)>1 ? 's' : '') . "\n";
		foreach my $label (@exist_containers){
			echo "  | - $label ";
			`docker rm -f $label $hide_all`;
			if($?) {
				style({color=>'red'});
				echo "NG\n";
				style({color=>'clear'});
			} else {
				echo "deleted\n";
			}
		}
		style(color=>'clear', bgcolor=>'clear');
		print "\n";
	}

	# -- DataVolume削除（個別起動時のみ）
	if($up_type && @volumes) {
		map { `docker volume rm $_` } @volumes;
	}

}

# --------------------------------------------------------------------
# genie cli (command line)              コマンドラインに入る・実行する
# --------------------------------------------------------------------
sub cli {
	return unless require_up(); # 起動必須
	my $cmd;
	if($ARGV[1]) {
		# -- 続きの引数があればそのまま渡して実行
		$cmd = 'docker exec -it ' . $config{DOCKER}->{NAME} . ' ' . join(' ', @ARGV[1..$#ARGV]);
	} else {
		# -- 引数が`cli`のみであれば bash に入る
		$cmd = 'docker exec -it ' . $config{DOCKER}->{NAME} . ' /bin/bash';
	}
	system($cmd);
	echo "\n";
}

# --------------------------------------------------------------------
# genie ls                            マシン、イメージ、コンテナの一望
# --------------------------------------------------------------------
sub ls {

	# -- Dockerマシン一覧
	if($is_docker_machine) {
		echo "  Dockerマシン一覧\n";
		my $result = `docker-machine ls`;
		message(info=>$result, 1);
		print "\n";
	}

	# -- ACTIVEマシンのイメージ一覧
	{
		echo "  イメージ一覧\n";
		my $result = `docker images`;
		message(info=>$result, 1);
	}

	# -- ACTIVEマシンのデータボリューム一覧
	{
		echo "  データボリューム一覧\n";
		my $result = `docker volume ls`;
		message(info=>$result, 1);
	}

	# -- ACTIVEマシンのコンテナ一覧
	{
		echo "  コンテナ一覧\n";
		my $result = `docker ps -a`;
		message(info=>$result, 1);
	}
	print "\n";
}

# --------------------------------------------------------------------
# genie reject                dockerが管理する全コンテナを強制削除する
# --------------------------------------------------------------------
sub reject {
	my @list = split(/[\r\n]+/, `docker ps -qa`);
	if(@list) {
		my @err;
		foreach my $id (@list) {
			echo "  $id - ";
			`docker rm -f $id`;
			if($?) {
				style(color=>'red'); echo "Failed!\n"; style(color=>'clear');
				push @err;
			} else {
				style(color=>'green'); echo "Deleted.\n"; style(color=>'clear');
			}
		}
		if(@err) {
			message(danger=>'強制削除に失敗したコンテナがあります。\n'.join('',map{"- $_\n"}@err));
		} else {
			message(success=>'全てのコンテナを強制削除しました');
		}
	} else {
		message(warning=>'コンテナが１つも見つかりませんでした。');
	}

	&clean();
}

# --------------------------------------------------------------------
# genie clean               不要なコンテナやイメージ、ボリュームを削除
# --------------------------------------------------------------------
sub clean {

	# -- 終了済みコンテナを削除
	{
		my @list = split(/[\r\n]+/, `docker ps -qa --filter status=exited`);
		if(@list) {
			my @err;
			foreach my $id (@list) {
				echo "  $id - ";
				`docker rm $id`;
				if($?) {
					style(color=>'red'); echo "Failed!\n"; style(color=>'clear');
					push @err;
				} else {
					style(color=>'green'); echo "Deleted.\n"; style(color=>'clear');
				}
			}
			if(@err) {
				message(danger=>'削除に失敗したコンテナがあります。\n'.join('',map{"- $_\n"}@err));
			} else {
				message(success=>'全ての終了済みコンテナを削除しました。');
			}
		} else {
			message(default=>'終了済みコンテナは見つかりませんでした。');
		}
	}

	# -- <none>イメージを削除する
	{
		my @list = split(/[\r\n]+/, `docker images -q --filter dangling=true`);
		if(@list) {
			my @err;
			foreach my $id (@list) {
				echo "  $id - ";
				`docker rmi $id`;
				if($?) {
					style(color=>'red'); echo "Failed!\n"; style(color=>'clear');
					push @err;
				} else {
					style(color=>'green'); echo "Deleted.\n"; style(color=>'clear');
				}
			}
			if(@err) {
				message(danger=>'削除に失敗した<none>イメージがあります。\n'.join('',map{"- $_\n"}@err));
			} else {
				message(success=>'全ての<none>イメージを削除しました。');
			}
		} else {
			message(default=>'<none>イメージは見つかりませんでした。');
		}
	}

	# -- 未参照のデータボリュームを削除する
	{
		my @list = split(/[\r\n]+/, `docker volume ls -q --filter dangling=true`);
		if(@list) {
			my @err;
			my $deleted;
			my $undeleted;
			echo "  Deleting data volumes\n";
			foreach my $id (@list) {
				echo "  | - $id ";
				# -- lockedから始まるVolume名は削除しない。ただし「genie clean locked」で完全削除可能。
				if( $id =~ /^locked/i && $ARGV[1] ne 'locked' ){
					$undeleted ++;
					style(color=>'yellow'); echo "is locked.\n"; style(color=>'clear');
					next;
				}
				# -- productから始まるVolume名は削除しない。ただし「genie clean product」で完全削除可能。
				if( $id =~ /^product/i && $ARGV[1] ne 'product' ){
					$undeleted ++;
					style(color=>'yellow'); echo "is product.\n"; style(color=>'clear');
					next;
				}
				`docker volume rm $id $hide_all`;
				if($?) {
					style(color=>'red'); echo "Failed!\n"; style(color=>'clear');
					push @err;
				} else {
					style(color=>'green'); echo "Deleted.\n"; style(color=>'clear');
					$deleted ++;
				}
			}
			if(@err) {
				message(danger=>'削除に失敗した未参照のデータボリュームがあります。\n'.join('',map{"- $_\n"}@err));
			} else {
				if($deleted) {
					message(success=>"${deleted}個のデータボリュームを削除しました。");
				}
				if($undeleted) {
					message(warning=>"${undeleted}個のデータボリュームが削除できない名前になっています。（`locked`または`product`から始まる）\n但し、`genie clean <locked|product>` で強制削除できます。");
				}
			}
		} else {
			message(default=>'未参照のデータボリュームは見つかりませんでした。');
		}
	}
}


# --------------------------------------------------------------------
# genie config                                    設定の内容を確認する
# --------------------------------------------------------------------
sub config {

	# -- エディタで開けそうなら開く。そうでなければ、または「genie config dump」なら、単に画面に表示する
	if($open_cmd && $ARGV[1] ne 'dump'){
		return `$open_cmd $config{GENERAL}->{config_file} $open_cmd_after`;
	} else {
		message(info=>Dumper(\%config));
	}

}

# --------------------------------------------------------------------
# genie httpd            簡易ローカルWebサーバ起動（設定ファイル不要）
# --------------------------------------------------------------------
sub httpd {

	# -- コンテナ起動
	my $cmd = "docker run -d -t -p 80 -e TERM=xterm -v $now_path:/var/www/html/ -e GENIE_PROC=httpd $config{DOCKER}->{IMAGE}";
	my $cid = `$cmd`;
	if($?) {
		throw('Webサーバが起動しませんでした。', $cmd);
	}
	chomp $cid;

	# -- コンテナの情報からブラウザを起動
	if(`docker port $cid 80` =~ /(\d+)$/) {

		# -- ブラウザ起動
		my $url = "http://$config{GENERAL}->{host_ip}:$1/";
		message(success=>$url);
		if($open_cmd){
			`$open_cmd $url $open_cmd_after`;
		}

		# -- ngrok起動
		system "docker exec -it $cid ngrok http 80";

		# -- コンテナ削除
		print "\nDeleting container $cid ...\n\n";
		`docker rm -f $cid`;

	} else {
		throw('サーバは起動しましたが、ポートが取得できませんでした。');
	}
}

# --------------------------------------------------------------------
# genie build                             kazaoki/genie イメージビルド
# --------------------------------------------------------------------
sub build {

	# -- nocacheオプション
	my $nocache = '--no-cache' if ($ARGV[1] eq 'nocache');

	# -- .genie/Dockerfileをビルドする
	my $dockerfile = "$config{GENERAL}->{config_dir}/genie/opt/build/Dockerfile";
	if(! -s $dockerfile){
		throw('Dockerfileが見つからないか、空ファイルです。', $dockerfile);
	}

	# -- 確認
	my $input;
	my $machine_name;
	if($is_docker_machine) {
		$machine_name = $config{DOCKER}->{MACHINE} || `docker-machine active`;
	}
	if($is_docker_machine && $machine_name) {
		chomp $machine_name;
		$input = input(
			sprintf(
				'%s マシーンに %s イメージをビルドしてもよろしいでしょうか。[y/N]: ',
				$machine_name,
				$config{DOCKER}->{IMAGE},
			)
		);
	} else {
		$input = input(
			sprintf(
				'%s イメージをビルドしてもよろしいでしょうか。[y/N]: ',
				$config{DOCKER}->{IMAGE},
			)
		);
	}

	print "\n";
	if($input =~ /^y$/i ) {
		# -- ビルド実行
		my $cmd =
			"docker build".
			" -t $config{DOCKER}->{IMAGE}".
			" $nocache $config{GENERAL}->{config_dir}/genie/opt/build/"
		;
		message(info=>"ビルドを開始します。\n$cmd");
		my $result = `$cmd`;
		if($?) {
			throw('ビルドに失敗しました。', $result);
		}
		# -- イメージ一覧表示
		message(success=>'ビルド完了しました。');
		$cmd = `docker images`;
		message(info=>$cmd, 1);
	}
}

# --------------------------------------------------------------------
# genie php                                                    PHP情報
# --------------------------------------------------------------------
sub php {
	print `docker run --rm --entrypoint=bash kazaoki/genie -c "/root/.anyenv/envs/phpenv/plugins/php-build/bin/php-build --definitions"`;
	if(&is_up()){
		print "\n---\n\n";
		print `docker exec $config{DOCKER}->{NAME} bash -c ". /root/.bashrc && phpenv versions"`;
	}
	print "\n";
}

# --------------------------------------------------------------------
# genie perl                                                  Perl情報
# --------------------------------------------------------------------
sub perl {
	print `docker run --rm --entrypoint=bash kazaoki/genie -c "/root/.anyenv/envs/plenv/plugins/perl-build/perl-build  --definitions"`;
	if(&is_up()){
		print "\n---\n\n";
		print `docker exec $config{DOCKER}->{NAME} bash -c ". /root/.bashrc && plenv versions"`;
	}
	print "\n";
}

# --------------------------------------------------------------------
# genie ruby                                                  Ruby情報
# --------------------------------------------------------------------
sub ruby {
	print `docker run --rm --entrypoint=bash kazaoki/genie -c "/root/.anyenv/envs/rbenv/plugins/ruby-build/bin/ruby-build  --definitions"`;
	if(&is_up()){
		print "\n---\n\n";
		print `docker exec $config{DOCKER}->{NAME} bash -c ". /root/.bashrc && rbenv versions"`;
	}
	print "\n";
}

# --------------------------------------------------------------------
# genie ngrok                                          ngrokを利用する
# --------------------------------------------------------------------
sub ngrok {
	# -- QRcode show on browser (if subdomain specified.)
	if($open_cmd && $config{NGROK}->{SUBDOMAIN}){
		`$open_cmd https://chart.googleapis.com/chart?cht=qr"&"chs=150x150"&"chl=https://$config{NGROK}->{SUBDOMAIN}.ngrok.io $open_cmd_after`;
	}
	# -- start ngrok
	my $token = $config{NGROK}->{AUTHTOKEN} ? "--authtoken=$config{NGROK}->{AUTHTOKEN}" : '';
	my $subdomain = $config{NGROK}->{SUBDOMAIN} ? "--subdomain=$config{NGROK}->{SUBDOMAIN}" : '';
	my $basicauth = ($config{NGROK}->{BASIC_USER} ne '' && $config{NGROK}->{BASIC_PASS} ne '') ? '-auth "' . $config{NGROK}->{BASIC_USER} . ':' . $config{NGROK}->{BASIC_PASS} . '"' : '';
	system "docker exec -it $config{DOCKER}->{NAME} ngrok $config{NGROK}->{ARGS} $token $subdomain $basicauth";
}

# --------------------------------------------------------------------
# genie mysql (options)                                      MySQL操作
# --------------------------------------------------------------------
sub mysql {
	return unless require_up(); # 起動必須
	my @dbs = @{$config{MYSQL}->{DATABASES}} if ref $config{MYSQL}->{DATABASES};

	# -- 引数未指定または数字
	if($ARGV[1] eq '' || $ARGV[1] =~ /^\d+$/ ) {
		my $db_number = $ARGV[1] =~ /^\d+$/ ? $ARGV[1] : 1;
		unless($db_number>0 && $db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するMySQL設定が見つかりません。'); }
		my $db = $config{MYSQL}->{DATABASES}[$db_number-1];
		my $cmd =
			qq|docker exec -it $config{DOCKER}->{NAME}-mysql-$db->{LABEL}|.
			qq| mysql $db->{NAME}|.
			qq| -u$db->{USER}|.
			qq| -p$db->{PASS}|
		;
		system $cmd;
	}
	# -- ls
	elsif($ARGV[1] eq 'ls' ) {
		my $count = 1;
		message(info=>join("\n", map { ($count++) . ': ' . $_->{LABEL} } @dbs));
	}
	# -- dump (db num) : 対象番号のDBをdump
	elsif($ARGV[1] eq 'dump') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : undef;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するMySQL設定が見つかりません。'); }
		`docker exec $config{DOCKER}->{NAME}-mysql-$dbs[0]->{LABEL} mkdir -p /mysql/opt/dumps/ $hide_all`;
		my $count = 1;
		foreach my $db (@dbs){
			if($db_number && $db_number!=$count++) { next; }
			my $label = "$config{DOCKER}->{NAME}-mysql-$db->{LABEL}";

			# -- ダンプファイルの世代処理
			my $max_gen = $db->{DUMP_GENEL};
			foreach my $gen (reverse 1..$max_gen) {
				my $gen_str = $gen==1 ? '' : ".$gen";
				if($gen==$max_gen) {
					my $cmd = qq|docker exec $label sh -c "rm /mysql/opt/dumps/$db->{LABEL}.sql$gen_str"|;
					`$cmd $hide_all`;
					next;
				}
				my $next = $gen + 1;
				my $cmd = qq|docker exec $label sh -c "cd /mysql/opt/dumps/ && mv $db->{LABEL}.sql$gen_str $db->{LABEL}.sql.$next"|;
				`$cmd $hide_all`;
			}

			# -- ダンプ生成
			my $cmd = qq|docker exec $label sh -c "mysqldump --single-transaction -u $db->{USER} -p$db->{PASS} $db->{NAME} > /mysql/opt/dumps/$db->{LABEL}.sql"|;
			`$cmd $hide_all`;
			if(!$?) {
				message(success=>"MySQLのデータベース $db->{LABEL} をダンプしました。\n$config{GENERAL_U}->{config_dir}/mysql/opt/dumps/$db->{LABEL}.sql", 1);
			} else {
				throw('データベースのダンプに失敗しました。', $!);
			}
		}
	}
	# -- restore (db num) : 対象番号のDBダンプを復元 ※番号未指定なら全てのDBを復元
	elsif($ARGV[1] eq 'restore') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : undef;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するMySQL設定が見つかりません。'); }
		my $count = 1;
		foreach my $db (@dbs){
			if($db_number && $db_number!=$count++) { next; }
			my $dumpfile = "$config{GENERAL}->{config_dir}/mysql/opt/dumps/$db->{LABEL}.sql";
			if(!-e $dumpfile) { next; }
			my $label = "$config{DOCKER}->{NAME}-mysql-$db->{LABEL}";

			# -- コンテナ起動用コマンドを取得
			my $cmd = `docker exec $label sh -c "cat /docker-run.cmd"`;
			if($is_win){ Encode::from_to($cmd, 'utf8', 'sjis') } # パスに日本語が入っている場合、Windowsの場合はSJISにする必要がある。

			# -- 参照ボリューム名取得
			my @volumes = &get_data_volume_name($label);

			# -- コンテナ削除とボリューム削除（DataVolume名がLOCKLED_だろうと削除します）
			style(color=>'black', bgcolor=>'dark_black');
			echo "  Delete MySQL container: $label";
			`docker rm -f $label $hide_all`;
			if($?) {
				style({color=>'red'});
				echo "NG\n";
				style({color=>'clear'});
			} else {
				echo " deleted\n";
			}
			style(color=>'clear', bgcolor=>'clear');
			map { `docker volume rm $_` } @volumes;

			# -- コンテナを再起動
			`$cmd`;
			my $result = $?;
			`docker exec $label sh -c "echo '$cmd' > /docker-run.cmd"`;
			if(!$result) {
				# -- 起動開始のプログレス
				echo "  Restore MySQL container: $label";
				wait_container ({
					container_name => $label,
					proc_command   => 'entrypoint.sh',
					label_head     => '',
					label          => '',
				});
				if($is_win){ $dumpfile = &sjis2utf8($dumpfile) } # Windowsの場合、パスに日本語が入っている可能性があるので、SJISにする必要がある。
				message(success=>"MySQLのデータベース $db->{LABEL} を復元しました。\n$dumpfile", 1);
			} else {
				throw('データベースの復元に失敗しました。', $!);
			}
		}
	}
	# -- cli (db num) : 対象番号のDBコンテナに入る ※番号未指定なら1
	elsif($ARGV[1] eq 'cli') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : 1;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するMySQL設定が見つかりません。'); }
		my $db = $config{MYSQL}->{DATABASES}[$db_number-1];
		my $cmd = "docker exec -it $config{DOCKER}->{NAME}-mysql-$db->{LABEL} bash";
		system $cmd;
	}
	# -- 引数ミス
	else{
		throw('引数が間違っています');
	}
}

# --------------------------------------------------------------------
# genie psql (options)                                  PostgreSQL操作
# --------------------------------------------------------------------
sub psql {
	return unless require_up(); # 起動必須
	my @dbs = @{$config{POSTGRESQL}->{DATABASES}} if ref $config{POSTGRESQL}->{DATABASES};

	# -- 引数未指定または数字
	if($ARGV[1] eq '' || $ARGV[1] =~ /^\d+$/ ) {
		my $db_number = $ARGV[1] =~ /^\d+$/ ? $ARGV[1] : 1;
		unless($db_number>0 && $db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するPostgreSQL設定が見つかりません。'); }
		my $db = $dbs[$db_number-1];
		my $cmd =
			qq|docker exec -it $config{DOCKER}->{NAME}-postgresql-$db->{LABEL}|.
			qq| psql $db->{NAME} -U $db->{USER}|
		;
		system $cmd;
	}
	# -- ls
	elsif($ARGV[1] eq 'ls' ) {
		my $count = 1;
		message(info=>join("\n", map { ($count++) . ': ' . $_->{LABEL} } @dbs));
	}
	# -- dump (db num) : 対象番号のDBをdump
	elsif($ARGV[1] eq 'dump') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : undef;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するPostgreSQL設定が見つかりません。'); }
		`docker exec $config{DOCKER}->{NAME}-postgresql-$dbs[0]->{LABEL} mkdir -p /postgresql/opt/dumps/ $hide_all`;
		my $count = 1;
		foreach my $db (@dbs){
			if($db_number && $db_number!=$count++) { next; }
			my $label = "$config{DOCKER}->{NAME}-postgresql-$db->{LABEL}";

			# -- ダンプファイルの世代処理
			my $max_gen = $db->{DUMP_GENEL};
			foreach my $gen (reverse 1..$max_gen) {
				my $gen_str = $gen==1 ? '' : ".$gen";
				if($gen==$max_gen) {
					my $cmd = qq|docker exec $label sh -c "rm /postgresql/opt/dumps/$db->{LABEL}.sql$gen_str"|;
					`$cmd $hide_all`;
					next;
				}
				my $next = $gen + 1;
				my $cmd = qq|docker exec $label sh -c "cd /postgresql/opt/dumps/ && mv $db->{LABEL}.sql$gen_str $db->{LABEL}.sql.$next"|;
				`$cmd $hide_all`;
			}

			# -- ダンプ生成
			my $cmd = qq|docker exec $label sh -c "pg_dump $db->{NAME} -U $db->{USER} > /postgresql/opt/dumps/$db->{LABEL}.sql"|;
			`$cmd`;
			if(!$?) {
				my $dumpfile = "$config{GENERAL}->{config_dir}/postgresql/opt/dumps/$db->{LABEL}.sql";
				if($is_win){ $dumpfile = &sjis2utf8($dumpfile) } # Windowsの場合、パスに日本語が入っている可能性があるので、SJISにする必要がある。
				message(success=>"PostgreSQLのデータベース $db->{LABEL} をダンプしました。\n$dumpfile", 1);
			} else {
				throw('データベースのダンプに失敗しました。', $!);
			}
		}
	}
	# -- restore (db num) : 対象番号のDBをtarからストレージに復元 ※番号未指定なら全てのDBを復元
	elsif($ARGV[1] eq 'restore') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : undef;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するPostgreSQL設定が見つかりません。'); }
		my $count = 1;
		foreach my $db (@dbs){
			if($db_number && $db_number!=$count++) { next; }
			my $dumpfile = "$config{GENERAL}->{config_dir}/postgresql/opt/dumps/$db->{LABEL}.sql";
			if(!-e $dumpfile) { next; }
			my $label = "$config{DOCKER}->{NAME}-postgresql-$db->{LABEL}";

			# -- コンテナ起動用コマンドを取得
			my $cmd = `docker exec $label sh -c "cat /docker-run.cmd"`;
			if($is_win){ Encode::from_to($cmd, 'utf8', 'sjis') } # パスに日本語が入っている場合、Windowsの場合はSJISにする必要がある。

			# -- 参照ボリューム名取得
			my @volumes = &get_data_volume_name($label);

			# -- コンテナ削除とボリューム削除（DataVolume名が<locked|product>から始まるものだろうと削除します）
			style(color=>'black', bgcolor=>'dark_black');
			echo "  Delete PostgreSQL container: $label";
			`docker rm -f $label $hide_all`;
			if($?) {
				style({color=>'red'});
				echo "NG\n";
				style({color=>'clear'});
			} else {
				echo " deleted\n";
			}
			style(color=>'clear', bgcolor=>'clear');
			map { `docker volume rm $_` } @volumes;

			# -- コンテナを再起動
			`$cmd`;
			my $result = $?;
			`docker exec $label sh -c "echo '$cmd' > /docker-run.cmd"`;
			if(!$result) {
				# -- 起動開始のプログレス
				echo "  Restore PostgreSQL container: $label";
				wait_container ({
					container_name => $label,
					proc_command   => 'entrypoint.sh',
					label_head     => '',
					label          => '',
				});
				if($is_win){ $dumpfile = &sjis2utf8($dumpfile) } # Windowsの場合、パスに日本語が入っている可能性があるので、SJISにする必要がある。
				message(success=>"PostgreSQLのデータベース $db->{LABEL} を復元しました。\n$dumpfile",1);
			} else {
				throw('データベースの復元に失敗しました。', $!);
			}
		}
	}
	# -- cli (db num) : 対象番号のDBコンテナに入る ※番号未指定なら1
	elsif($ARGV[1] eq 'cli') {
		my $db_number = $ARGV[2] =~ /^\d+$/ ? $ARGV[2] : 1;
		unless($db_number<=scalar(@dbs)) { throw('指定されたDB番号に対応するPostgreSQL設定が見つかりません。'); }
		my $db = $config{POSTGRESQL}->{DATABASES}[$db_number-1];
		my $cmd = "docker exec -it $config{DOCKER}->{NAME}-postgresql-$db->{LABEL} bash";
		system $cmd;
	}
	# -- 引数ミス
	else{
		throw('引数が間違っています');
	}
}

# --------------------------------------------------------------------
# genie open                                            ブラウザを開く
# --------------------------------------------------------------------
sub open {
	# -- コンテナの情報からブラウザを起動
	if(`docker port $config{DOCKER}->{NAME} $config{BROWSER}->{OPEN_IN_PORT}` =~ /(\d+)$/) {
		my $port_str = ":$1";
		if($config{BROWSER}->{OPEN_SCHEMA} eq 'http' && $port_str eq ':80') { $port_str = ''; }
		elsif($config{BROWSER}->{OPEN_SCHEMA} eq 'https' && $port_str eq ':443') { $port_str = ''; }
		my $url = "$config{BROWSER}->{OPEN_SCHEMA}://$config{GENERAL}->{host_ip}$port_str/";
		if($config{BROWSER}->{OPEN_PATH}){
			$url =~ s/\/$//;
			$url .= $config{BROWSER}->{OPEN_PATH};
		}		
		message(success=>$url);
		if($open_cmd){
			`$open_cmd $url $open_cmd_after`;
		}
	}
}

# --------------------------------------------------------------------
# genie logs                                        ログファイルを開く
# --------------------------------------------------------------------
sub logs {
	if(defined $config{LOGS}->{FILES} && ref $config{LOGS}->{FILES}) {
		my $log_files = join(' ', @{$config{LOGS}->{FILES}});
		my $split = $config{LOGS}->{SPLIT} ? '-s '.$config{LOGS}->{SPLIT} : '';
		my $cmd = qq|docker exec -ti $config{DOCKER}->{NAME} script /dev/null -qc "multitail $split $log_files"|;
		system $cmd;
	}
}

# --------------------------------------------------------------------
# genie dlsync                                            dlsyncを実行
# --------------------------------------------------------------------
sub dlsync {
	if(
		   $config{DLSYNC}->{REMOTE_HOST}
		&& $config{DLSYNC}->{REMOTE_USER}
		&& $config{DLSYNC}->{REMOTE_PASS}
		&& $config{DLSYNC}->{REMOTE_DIR}
		&& $config{DLSYNC}->{LOCAL_DIR}
	) {

		# -- デフォルト引数を適用（直接引数が指定されていればそちらを優先）
		if((!($ARGV[1]||$options{all}||$options{'now-branch'}||$options{'oldest-branch'})) && $config{DLSYNC}->{DEFAULT_ARGV}){
			if($config{DLSYNC}->{DEFAULT_ARGV} =~ /\-\-?(all|now\-branch|oldest\-branch)/){
				$options{$1} = 1;
			} else {
				$config{DLSYNC}->{DEFAULT_ARGV} =~ s/^\s+//;
				$config{DLSYNC}->{DEFAULT_ARGV} =~ s/\s+$//;
				@ARGV = ( $ARGV[0], split(/\s+/, $config{DLSYNC}->{DEFAULT_ARGV}));
			}
		}

		# -- ブランチ情報を取得
		my %branch2date;
		my $oldest_date;
		my $oldest_branch;
		my $now_branch;
		foreach(`git branch -v $hide_err`){
			my $line = Encode::decode('utf8', $_); # 実行結果はフラグ無しutf8なのでフラグ付けておく
			my @column = split(/\s+/, $line);
			if($column[0] =~ /\*/) { $now_branch = $column[1] }
			my $date;
			if(`git show $column[1] -q --date=short $hide_err` =~ /Date: *(\d{4}\-\d{2}\-\d{2})/){ $date = $1; }
			$branch2date{$column[1]} = $date;
			$date =~ s/\D//g;
			$oldest_date ||= $date; $oldest_branch ||= $column[1];
			if($oldest_date>$date) { $oldest_date = $date; $oldest_branch = $column[1]; }
		}

		# -- all：全てダウンロード
		if($options{all}){
			;
		}
		# -- 引数なし：引数のヘルプとサンプル
		elsif(!($ARGV[1]||$options{'now-branch'}||$options{'oldest-branch'})){
			message(info=>
				"dlsyncには以下の引数が指定できます。必ずどれか指定してください。\n".
				"指定のGitブランチの最終コミット以降のファイルをDL同期する。\n".
				"  - genie dlsync master\n".
				"  - genie dlsync develop\n".
				"指定の年月日以降のファイルをDL同期する。\n".
				"  - genie dlsync 20160412\n".
				"  - genie dlsync 2016-04-12\n".
				"  - genie dlsync 2016-4-12\n".
				"  - genie dlsync 2016/04/12\n".
				"指定の過去日数以降のファイルをDL同期する。\n".
				"  - genie dlsync 1day\n".
				"  - genie dlsync 365days\n".
				"全ファイルをDLする。\n".
				"  - genie dlsync --all\n".
				"現在のGitブランチの最終コミット日付以降のファイルをDL同期する。\n".
				"  - genie dlsync --now-branch\n".
				"一番古いGitブランチの最終コミット日付以降のファイルをDL同期する。\n".
				"  - genie dlsync --oldest-branch\n".
				'※config.plにデフォルトを指定すると引数無しで実行することができます。',
			1);

			# -- ブランチ参考表示
			if(scalar(keys %branch2date)){
				echo "  [hint by branch]\n";
				my $branch_length = 0;
				foreach(keys %branch2date){
					my $len = length( Encode::encode('sjis', $_)); # マルチバイトは2として計算
					if($branch_length<$len) { $branch_length = $len; }
				}
				foreach my $branch (sort keys %branch2date){
					my $len = length( Encode::encode('sjis', $branch)); # マルチバイトは2として計算
					echo sprintf('  $ genie dlsync %s'.(' 'x($branch_length-$len)).' | %10s | %s',
						$branch,
						$branch2date{$branch},
						join(' ', grep{$_}($branch eq $oldest_branch ? '--oldest-branch':''),($branch eq $now_branch ? '--now-branch':''))
					);
					echo "\n";
				}
				echo "\n";
			}

			return;

		}

		# -- 引数有り
		else {

			# -- 引数で指定された、現在のブランチ/最古のブランチ名のセット
			if($options{'now-branch'}) { $ARGV[1] = $now_branch;}
			elsif($options{'oldest-branch'}) { $ARGV[1] = $oldest_branch;}

			# -- ブランチ名指定
			if($branch2date{$ARGV[1]}){
				if($branch2date{$ARGV[1]} =~ /^(\d{4})[\-\/]?(\d{1,2})[\-\/]?(\d{1,2})$/){
					my $time = sprintf('%04d-%02d-%02d 00:00:00', $1, $2, $3);
					$config{DLSYNC}->{LFTP_OPTION} .= ' --newer-than=now-'.(int((time - str2time($time))/60)+1).'minutes';
				}
			}
			# -- 日付指定
			elsif($ARGV[1] =~ /^(\d{4})[\-\/]?(\d{1,2})[\-\/]?(\d{1,2})$/){
				my $time = sprintf('%04d-%02d-%02d 00:00:00', $1, $2, $3);
				$config{DLSYNC}->{LFTP_OPTION} .= ' --newer-than=now-'.(int((time - str2time($time))/60)+1).'minutes';
			}
			# -- days指定
			elsif($ARGV[1] =~ /^(\d+)days?$/){
				$config{DLSYNC}->{LFTP_OPTION} .= ' --newer-than=now-'.($1*60*60*24).'minutes';
			}
			# -- 指定ミス
			else {
				message(danger=>'ご指定のブランチが見つからない、または日付の指定が間違っています：'.$ARGV[1]);
				exit 1;
			}

		}

		# -- 新たなコンテナを作成してlftpを実行。そして自動的に終了する。
		my $local_dir_path = ($config{DLSYNC}->{LOCAL_DIR} =~ /^\//)
			? $config{DLSYNC}->{LOCAL_DIR}
			: $config{GENERAL}->{home_dir} .'/'. $config{DLSYNC}->{LOCAL_DIR}
		;
		my $envs = join(' ', map { "-e GENIE_DLSYNC_$_=\"" . $config{DLSYNC}->{$_} . '"' } keys %{$config{DLSYNC}} );
		my $cmd =
			"docker run --rm -it".
			" -e GENIE_PROC=dlsync".
			" $envs".
			" -v $local_dir_path:/sync".
			" -v $config{GENERAL}->{config_dir}/genie/opt:/opt".
			" $config{DOCKER}->{IMAGE}"
		;
		system $cmd;

		# -- アナウンス
		say('ダウンロード同期が完了しました。');

	} else {
		message(warning=>'dlsync用の設定をされていないようです。');
	}
	return;
}

# --------------------------------------------------------------------
# genie spec                                            SPECを実行する
# --------------------------------------------------------------------
sub spec {

	# -- fastモードの場合はコンテナ起動必須
	if($options{fast}){
		return unless require_up(); # 起動必須
	}

	# -- featureファイルの一覧表示のみ
	if(!($options{all}||$ARGV[1] ne '')) {
		my @list = &_spec_files($config{GENERAL}->{config_dir} . '/spec/features');
		if(@list){
			my $list = "featureファイル名（前方一致）を指定するか `--all` を指定してください。\n";
			foreach my $feature_file (@list) {
				$feature_file =~ s/^$config{GENERAL}->{config_dir}\/spec\/features\///;
				$list .= "$feature_file\n";
			}
			message(info=>$list, 1);
		} else {
			message(warning=>"featureファイルがありません。以下のディレクトリを確認してください。\n$config{GENERAL_U}->{config_dir}/spec/features/", 1);
		}
	}

	# -- 引数指定
	else {
		my $files_args = '/spec/features/';
		# -- all指定
		if($options{all}) {
			message(info=>'全てのfeatureファイルをテストします。');
		}
		# -- featureファイル指定
		elsif($ARGV[1]) {
			my @files_show;
			my @files_args;
			foreach my $num (1..$#ARGV){
				foreach( &_spec_files($config{GENERAL}->{config_dir} . '/spec/features', $ARGV[$num]) ){
					$_ =~ s/^$config{GENERAL}->{config_dir}\/spec\/features\///;
					push @files_show, $_;
					push @files_args, "/spec/features/$_";
				}
				if(!scalar(@files_show)){
					message(danger=>"ご指定のfeatureファイルは見つかりませんでした。\n$ARGV[$num]", 1);
					return;
				}
			}
			message(info=>"以下のfeatureファイルをテストします。\n" . join("\n", @files_show), 1);
			$files_args = join(' ', @files_args);
		}

		# -- fastモードの場合
		if($options{fast} && !$config{SPEC}->{SILENT_FAST}){
			# -- 確認する
			my $input = input('起動中のコンテナ上でSPEC実行してよろしいでしょうか（fastモード） [y/N]: ');
			print "\n";
			return if $input !~ /^y$/i;
		}

		# -- SPEC用コンテナを起動（fast時は起動しない）
		&up('spec') if !$options{fast};

		# -- コンテナ名用意
		my $container_name = ($options{fast} ? '' : 'SPEC-').$config{DOCKER}->{NAME};

		# -- 判別ファイル作成（fastモードの場合、環境変数で情報もっていけないのでファイルを作成しておく）
		`docker exec $container_name touch /var/run/genie_spec`;
		`docker exec $container_name touch /var/run/genie_nosend` if $config{SPEC}->{NO_SENDMAIL};

		# -- SPECを実行
		my $cmd;
		if($options{fast}){
			my $env = 'export GENIE_PROC=spec &&';
			$env .= $options{cap} ? ' export GENIE_SPEC_AUTOCAP=1 &&' : '';
			$cmd = "docker exec -it $container_name sh -c \"$env . /root/.bashrc && cd /turnip/ && bundle exec rspec --color $files_args\"";
		} else {
			$cmd = "docker exec -it $container_name sh -c \". /root/.bashrc && cd /turnip/ && bundle exec rspec --color $files_args\"";
		}
		my $res = system $cmd;

		# -- fastモードじゃない場合はレポートをコピーしてくる
		if(!$options{fast}){
			`docker exec -it $container_name sh -c \"\\cp -f /spec/report.html /_/spec/report.html\"`;
		}

		echo "\n";

		# -- 判別ファイル削除
		`docker exec $container_name rm -fr /var/run/genie_spec`;
		`docker exec $container_name rm -fr /var/run/genie_nosend` if $config{SPEC}->{NO_SENDMAIL};

		# -- アナウンス
		say('レポートを開きます。' . ($res ? 'エラーがありますので確認してください。' : 'オッケーです。'));

		# -- ブラウザでレポートを開く
		if($open_cmd){
			my $report = "$config{GENERAL}->{config_dir}/spec/report.html";
			$cmd = "$open_cmd $report $open_cmd_after";
			`$cmd`;
		}

		# -- SPEC用コンテナを終了（fast時は起動しない）
		&down('spec') if !$options{fast};

	}

	return 1;
}
# spec用featureファイルの検出（再帰的）
# -------------------------------------
sub _spec_files {
	my ($path, $filter) = @_;
	my @list;
	opendir my $dh, $path;
	while(my $file = readdir $dh){
		next if $file =~ /^\.+$/;
		my $dirfile = "$path/$file";
		if(-d $dirfile) {
			push @list, &_spec_files($dirfile, $filter);
		} else {
			next if $dirfile !~ /\.feature$/;

			next if $filter ne '' && index($dirfile, $config{GENERAL}->{config_dir}.'/spec/features/'.$filter)!=0; # 前方一致検索
			push @list, $dirfile;
		}
	}
	closedir $dh;
	return @list;
}

# --------------------------------------------------------------------
# genie zap <url>                                  OWASP/ZAPを実行する
# --------------------------------------------------------------------
sub zap {
	my $target = $ARGV[1];

	# -- 引数が無ければヘルプ表示
	if(!$target){
		message(info=>
			"zapには引数が必要です。以下の例をご参照下さい。\n".
			"- genie zap 80\n".
			"- genie zap 443\n".
			"- genie zap 8080 http\n".
			"- genie zap http://$config{DOCKER}->{NAME}\n".
			"- genie zap https://$config{DOCKER}->{NAME}/\n".
			"- genie zap xml2html\n",
			1
		);
		return;
	}
	# -- ポート番号の指定ならそこからURLを生成
	elsif($target>0){
		my $scheme;
		if($ARGV[1] == 80) { $scheme = 'http'; }
		elsif($ARGV[1] == 443) { $scheme = 'https'; }
		if($ARGV[2]) { $scheme = $ARGV[2]; }
		$target = $scheme . '://' . $config{DOCKER}->{NAME} . ":$target";
	}

	# -- レポートファイルパス設定
	my $report_xml  = "$config{GENERAL}->{config_dir}/zap/report.xml";
	my $report_html = "$config{GENERAL}->{config_dir}/zap/report.html";

	# -- xmlからhtmlへのコンバートのみ
	if($target eq 'xml2html'){
		&_report_xml2html($report_xml, $report_html);
		print "\n";
		message(success=>"セキュリティレポートを書き出しました。\n$report_html", 1);
		my $cmd = "$open_cmd $report_html $open_cmd_after";
		`$cmd`;
		return 1;
	}

	# -- 確認する
	my $input = input("$target に対して破壊的スキャンが実行される場合がありますがよろしいでしょうか。[y/N]: ");
	print "\n";
	return if $input !~ /^y$/i;

	# -- 既存のZAPRUNコンテナがあれば削除
	my $zap_container_name = "ZAPRUN-$config{DOCKER}->{NAME}";
	if(is_exist($zap_container_name)){
		style(color=>'black', bgcolor=>'dark_black');
		echo "  Deleting exist ZAPRUN container\n";
		echo "  | - $zap_container_name ";
		`docker rm -f $zap_container_name $hide_all`;
		if($?) {
			style({color=>'red'});
			echo "NG\n";
			style({color=>'clear'});
		} else {
			echo "deleted\n";
		}
		style(color=>'clear', bgcolor=>'clear');
		print "\n";
	}

	# -- zapディレクトリ作成
	mkdir $config{GENERAL}->{config_dir} . '/zap';

	# -- ZAP用コンテナを起動
	&up('zap');

	# -- ZAP中のメール送信禁止判別ファイル作成
	my $nosend_cmd = 'touch /var/run/genie_nosend &&' if $config{ZAP}->{NO_SENDMAIL};

	# -- ZAP実行
	my $cmd = qq|docker run -u zap | . join(' ', map{ "--add-host=$_" } @{$config{DOCKER}->{HOSTS}}) . qq| --link ZAP-$config{DOCKER}->{NAME}:$config{DOCKER}->{NAME} --name $zap_container_name owasp/zap2docker-stable sh -c "$nosend_cmd /zap/zap.sh -daemon -quickurl $target -quickout /tmp/report.xml -quickprogress" $hide_err|;

	# -- コンテナ実行
	my $pid = fork;
	die "Cannot fork: $!" unless defined $pid;
	if($pid){
		my $cmd = qq|docker logs $zap_container_name 2>&1|;
		while(1){
			sleep 1;
			my $res = `$cmd`;
			if($res =~ /ZAP is now listening/){
				last;
			}
		}

		# -- レポートファイルをコピーしてくる
		$cmd = qq|docker cp $zap_container_name:/tmp/report.xml $report_xml|;
		`$cmd`;
		if($?){
			message(danger=>'レポートの取得に失敗しました。');
			return !$?;
		}

		# -- レポートXMLからHTMLを生成する
		&_report_xml2html($report_xml, $report_html);
		print "\n";
		say('セキュリティチェックが完了しましたので、レポートを出力しました。');
		message(success=>"セキュリティレポートを書き出しました。\n$report_html", 1);

		# -- レポートを開く
		my $cmd = "$open_cmd $report_html $open_cmd_after";
		`$cmd`;

		# -- コンテナを削除
		`docker rm -f $zap_container_name $hide_all`;
		wait();

	} else {
		system($cmd);
		exit;
	}

	# -- ZAP用コンテナを終了
	&down('zap');

	return 1;

}

# -- HTMLエスケープ
sub _h {
	my $str = shift;
	return if !defined $str;
	$str =~ s/&/&amp;/go;
	$str =~ s/\"/&quot;/go;
	$str =~ s/>/&gt;/go;
	$str =~ s/</&lt;/go;
	return $str;
}

# -- zapレポートXMLファイルの変換→HTML
sub _report_xml2html {
	my($in_xml, $out_html) = @_;

	# -- XMLデータを順番に記憶する
	# 参考：http://blog.dealforest.net/2009/09/xml-parse-in-order/
	*XML::Simple::new_hashref = 'new_hashref';
	sub new_hashref {
		my $self = shift;
		tie my %hash, 'Tie::IxHash';
		%hash = @_; 
		return \%hash;
	}
	# -- XMLを読み込んでHTMLを生成する
	my $parser = XML::Simple->new();
	my $xml = $parser->XMLin($in_xml, ForceArray=>['site', 'instance', 'alertitem'] );

	my @class = ('', 'default', 'warning', 'danger');
	my $html;
	$html .= qq|<!doctype html>|;
	$html .= qq|<html><head>|;
	$html .= qq|<meta charset="utf-8">|;
	$html .= qq|<title>$config{DOCKER}->{NAME} セキュリティレポート</title>|;
	$html .= qq|<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">|;
	$html .= qq|</head><body>|;
	$html .= qq|<div class="container">|;
	$html .= qq|<div class="page-header"><h1>$config{DOCKER}->{NAME} セキュリティレポート</h1>|;
	if(keys %{$xml->{site}}>1){
		$html .= qq|<ul>|;
		foreach my $url (keys %{$xml->{site}}){
			$html .= qq|<li><a href="#$url">$url &raquo;</a></li>|;
		}
		$html .= qq|</ul>|;
	}
	$html .= qq|</div>|;

	foreach my $url (keys %{$xml->{site}}){
		my $site = $xml->{site}->{$url};
		if(!$site->{alerts}->{alertitem}){ next; }
		$html .= qq|<section style="margin-bottom:100px">|;
		$html .= qq|<h2 id="$url">$url</h2>|;
		$html .= qq|<div class="row">|;
		$html .= qq|<div class="col-md-6">|;
		$html .= qq|<table class="table table-bordered">|;
		$html .= qq|<thead><tr><th>Level</th><th>Alert</th><th>Count</th></tr></thead>|;
		$html .= qq|<tbody>|;
		my $anchor = 1;

		foreach (keys %{$site->{alerts}->{alertitem}}){
			my $item = $site->{alerts}->{alertitem}->{$_};
			my $level = ( $item->{riskcode}==1 ? 'Low' : $item->{riskcode}==2 ? 'Medium' : 'High');
			my $class = ( $item->{riskcode}==1 ? 'default' : $item->{riskcode}==2 ? 'warning' : 'danger');
			$html .= qq|<tr class="$class">|;
			$html .= qq|<td>$level</td>|;
			$html .= qq|<td><a href="#issue-$anchor">$item->{alert}</a></td>|;
			$html .= qq|<td class="text-right">$item->{count}</td>|;
			$html .= qq|</tr>|;
			$anchor ++;
		}
		$html .= qq|</tbody>|;
		$html .= qq|</table>|;
		$html .= qq|</div>|;
		$html .= qq|<div class="col-md-6">|;
		$html .= qq|<dl class="dl-horizontal">|;
		$html .= qq|<dt>Generate</dt>|;
		$html .= qq|<dd>$xml->{generated}</dd>|;
		$html .= qq|<dt>Version</dt>|;
		$html .= qq|<dd>$xml->{version}</dd>|;
		$html .= qq|<dt>Host</dt>|;
		$html .= qq|<dd>$site->{host}</dd>|;
		$html .= qq|<dt>Port</dt>|;
		$html .= qq|<dd>$site->{port}</dd>|;
		$html .= qq|<dt>SSL</dt>|;
		$html .= qq|<dd>$site->{ssl}</dd>|;
		$html .= qq|<dt>URL</dt>|;
		$html .= qq|<dd>$url</dd>|;
		$html .= qq|</dl>|;
		$html .= qq|</div>|;
		$html .= qq|</div>|;
		$html .= qq|<hr>|;
		$anchor = 1;

		foreach (keys %{$site->{alerts}->{alertitem}}){
			my $item = $site->{alerts}->{alertitem}->{$_};
			$html .= qq|<div class="panel panel-$class[$item->{riskcode}]" id="issue-$anchor">|;
			$html .= qq|<div class="panel-heading">|;
			$html .= qq|<p class="pull-right">|;
			$html .= qq|<span class="btn btn-$class[$item->{riskcode}] disabled" style="cursor:default">$item->{riskdesc}</span>|;
			$html .= qq|</p>|;
			$html .= qq|<h4>$item->{alert}</h4>|;
			$html .= qq|</div>|;
			$html .= qq|<div class="panel-body">$item->{desc}</div>|;
			$html .= qq|<table class="table"><tbody><tr><td><div class="col-md-10">|;
			$html .= qq|<ul>|;
			my @list = @{$item->{instances}->{instance}};
			foreach my $inst (@list){
				$html .= qq|<li>$inst->{uri}|;
				if(grep { $_ ne 'uri' } keys %{$inst}){
					$html .= qq|<pre>|;
					foreach my $key (sort keys %{$inst}){
						if($key ne 'uri') {
							$html .= qq|<div><span class="label label-primary">$key</span> <code>| . _h($inst->{$key}) . qq|</code></div>|;
						}
					}
					$html .= qq|</pre>|;
				}
				$html .= qq|</li>|;
			}
			$html .= qq|</ul>|;
			$html .= qq|</div><div class="col-md-2">|;
			$html .= qq|<table class="table table-bordered table-condensed">|;
			foreach(qw/confidence cweid wascid pluginid/){
				$html .= qq|<tr>|;
				$html .= qq|<th>$_</th>|;
				$html .= qq|<td class="text-right">$item->{$_}</td>|;
				$html .= qq|</tr>|;
			}
			$html .= qq|</table></div></td></tr>|;
			$html .= qq|<tr><td><dl>|;
			foreach(qw/solution otherinfo reference/){
				my $label = $_;
				$label =~ s/^(.)/uc $1/e;
				my $value = $item->{$_};
				$value =~ s/<!--/\&lt\;\!\-\-/g;
				$value =~ s/-->/\-\-\&gt\;/g;
				if($item->{$_} ne ''){
					$html .= qq|<dt>$label</dt>|;
					$html .= qq|<dd>$value</dd>|;
				}
			}
			$html .= qq|</dl></td>|;
			$html .= qq|</tr></tbody></table>|;
			$html .= qq|</div>|;
			$anchor ++;
		}
		$html .= qq|</section>|;
	}
	$html .= qq|</div></body></html>|;

	# -- HTML書き出す
	open my $fh, ">$out_html" or die "can't write $out_html.";
	print $fh encode('UTF-8', $html);
	close $fh;

	return 1;

}

# --------------------------------------------------------------------
# genie compose                             Docker compose用設定を出力
# --------------------------------------------------------------------
sub compose {

	# -- RUNMODE設定
	$config{GENERAL}->{runmode} = 'product';

	# -- 基本設定
	$comp->{version} = 2;

	# -- ホームへの相対パスを取得
	my $cut = $now_path;
	$cut =~ s/$config{GENERAL}->{home_dir}//;
	$config{GENERAL}->{home_rel} = join('/', map{ '..' } 1..($cut =~ tr/\///));

	# -- 起動に必用な情報を収集してくる
	&up('compose');

	# -- 値を調整する関数用意
	sub _adjust{
		my $value_ref = shift;
		# 「$」→「$$」
		$$value_ref =~ s/\$/\$\$/g;
		# ローカルパスを相対パスに変更
		$$value_ref =~ s/$config{GENERAL}->{home_dir}/$config{GENERAL}->{home_rel}/g;
	}
	# -- 再帰して値調整を実行
	sub _subconv{
		my $data = shift;
		if(ref $data eq 'HASH'){
			foreach my $key (keys %{$data}){
				if(ref $data->{$key}) {
					&_subconv($data->{$key});
				} else {
					&_adjust(\$data->{$key});
				}
			}
		} elsif(ref $data eq 'ARRAY') {
			foreach my $num ( 0 .. $#{$data} ){
				if(ref $data->[$num]) {
					&_subconv($data->[$num]);
				} else {
					&_adjust(\$data->[$num]);
				}
			}
		}
	}
	&_subconv($comp);

	# -- YAML形式で標準出力に出力
	echo YAML::Tiny::Dump($comp);

	exit 0;
}
